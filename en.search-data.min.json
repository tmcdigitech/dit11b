[{"id":0,"href":"/dit11/appdev/","title":"App Development","parent":"11 DigiTech","content":""},{"id":1,"href":"/dit11/appdev/basics/events/","title":"Buttons and Labels","parent":"The Basics","content":" Creating a .kv File Separated our logic from our styling and elements There are a few conventions we need to follow when creating a .kv file.\nNaming: The name of your .kv file must follow the rules below in order for python/kivy to be able to see and load the file.\nIt must be all lowercase It must match with the name of your main class. (The one that has the build method) If the name of your main class ends in \u0026ldquo;app\u0026rdquo; (lowercase or uppercase) you must not include \u0026ldquo;app\u0026rdquo; in your file name. File Location: The file must be in the same directory as your python script.\nFile Extension: The file must be saved as type *All Files and end with .kv\nFor example:\nMy main classes name is MyApp. Therefore I will name my file my.kv. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import kivy from kivy.app import App from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout from kivy.uix.textinput import TextInput from kivy.uix.button import Button from kivy.uix.widget import Widget class MyGrid(Widget): pass class MyApp(App): # \u0026lt;- Main Class def build(self): return MyGrid() if __name__ == \u0026#34;__main__\u0026#34;: MyApp().run() If you have named your file correctly there is nothing else you need to do to ensure that it is linked with your python script.\nSetting up The Python Script Before continuing please import the following module from your python script. from kivy.uix.widget import Widget\nThe first thing we need to do to add widgets to our screen using .kv is set up an empty class in our python script. This class will simply inherit from Widget and will be what is used from within the kv file to add widgets. class MyGrid(Widget): pass Now ensure that your main classes build method returns an instance of MyGrid and we are ready to go. class MyApp(App): def build(self): return MyGrid()\nAdding Widgets From a .kv File Two important things to remember about .kv files:\nCapitals are Important Indentation is important The first thing we do when writing in a .kv is declare the class we will be adding widgets to. In my case it\u0026rsquo;s MyGrid. # Filename: my.kv \u0026lt;MyGrid\u0026gt;: The next step is to define the widgets that we want to add to that class. Each widget also has several properties associated with it that we can change. # Filename: my.kv \u0026lt;MyGrid\u0026gt;: Label: text: \u0026#34;Name: \u0026#34; TextInput: multiline:False You can see that the widgets that are inside of the MyGrid class are tabbed in once and the properties of those widgets are tabbed twice.\nCreating a Form With a .kv File The file below is a form asking the user for their name and email address using a kv file. You can see that we have multiple grid layouts and that we add widgets to those layouts.\nNotice that to make these widgets fill the entire screen we must change the size attribute. By making the size of the first grid layout root.width, root.height we are telling it to fill the size of the window dynamically. # Filename: my.kv \u0026lt;MyGrid\u0026gt;: GridLayout: cols:1 size: root.width, root.height GridLayout: cols:2 Label: text: \u0026#34;Name: \u0026#34; TextInput: multinline:False Label: text: \u0026#34;Email: \u0026#34; TextInput: multiline:False Button: text:\u0026#34;Submit\u0026#34; on_press: root.btn()\nObject Properties After experimenting with the .kv language some of you may have asked the question: How do we access our elements (textinput, button etc.) from our python script? Well that is an excellent question and is what we have object properties for!\nAn object property allows us to create a reference to widgets from within a .kv file from our python script.\nModifying the .kv File To set up object properties we need to create global variables from within our .kv file and assign these variables to the id property of specific widgets. \u0026lt;MyGrid\u0026gt;: name: name # Global variable name references the id name email: email # Global variable email references the id email GridLayout: cols:1 size: root.width - 200, root.height -200 pos: 100, 100 GridLayout: cols:2 Label: text: \u0026#34;Name: \u0026#34; TextInput: id: name # \u0026lt;- Add this multiline:False Label: text: \u0026#34;Email: \u0026#34; TextInput: id: email # \u0026lt;-Add this multiline:False Button: text:\u0026#34;Submit\u0026#34;\nModifying the Python Script The first thing we need to do to use an object property from within our python script is import the specific module. from kivy.properties import ObjectProperty Next we will define two object properties from within our class MyGrid. class MyGrid(Widget): name = ObjectProperty(None) email = ObjectProperty(None) We initialize the values as None to start as when we first create the class they will have no value. Now if we want to access the value of the TextInput box with id email we can simply use self.email to do so. Similarity for the name TextInput.\nCreating a Button On_Press Like we had in previous tutorials we\u0026rsquo;d like our button to perform a function when it is clicked. To accomplish this we need to create a method inside of our MyGrid class that we can call each time our button is pressed. We will call this btn(). # Goes inside MyGrid Class def btn(self): print(\u0026#34;Name:\u0026#34;, self.name.text, \u0026#34;email:\u0026#34;, self.email.text) self.name.text = \u0026#34;\u0026#34; self.email.text = \u0026#34;\u0026#34; This method will print the contents of our form and clear both of the text input boxes.\nNow we need to tell the button what it should call when it is pressed. To do this we will add the property on_press in our .kv file. Button: text:\u0026#34;Submit\u0026#34; on_press: root.btn() # \u0026lt;- Add this We use app.btn() to reference the class that contains our btn method.\nNow we should have a functioning application that works.\nFull Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import kivy from kivy.app import App from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout from kivy.uix.textinput import TextInput from kivy.uix.button import Button from kivy.uix.widget import Widget from kivy.properties import ObjectProperty class MyGrid(Widget): name = ObjectProperty(None) email = ObjectProperty(None) def btn(self): print(\u0026#34;Name:\u0026#34;, self.name.text, \u0026#34;email:\u0026#34;, self.email.text) self.name.text = \u0026#34;\u0026#34; self.email.text = \u0026#34;\u0026#34; class MyApp(App): def build(self): return MyGrid() if __name__ == \u0026#34;__main__\u0026#34;: MyApp().run() \u0026lt;MyGrid\u0026gt;: name: name email: email GridLayout: cols:1 size: root.width - 200, root.height -200 pos: 100, 100 GridLayout: cols:2 Label: text: \u0026#34;Name: \u0026#34; TextInput: id: name multiline:False Label: text: \u0026#34;Email: \u0026#34; TextInput: id: email multiline:False Button: text:\u0026#34;Submit\u0026#34; on_press: root.btn() "},{"id":2,"href":"/dit11/appdev/basics/classesandmethods/","title":"Classes and Methods","parent":"The Basics","content":" Object Oriented Programming (OOP) OOP has self-contained objects containing both the programming routine/procedures and the data being processed. These objects interact by sending data to one another.\nIn OOP, you write classes that represent real world things and create objects based on these classes. Classes attributes as well as procedures (often known as methods).\nClass The class is the blueprint, or template, that defines what an object is. This includes the type of data an object can hold, its initial value and how the object behaves.\nFrom classes, we can create instances. An instance is an object created from a particular class.\nIf we have a class called Dog, we can create as many instances (Dog1, Dog2, BigDog, SmellyDog) as we like – all with different ages and names.\nFor example, Dog1 might be an instance of the Dog class: class Dog: #creates the Dog class def __init__(self, name, age): self.name = name #self prefix allows all methods to access attributes self.age = age Dog1 = Dog(\u0026#39;Bruce\u0026#39;, 3) #creates object Dog1 - name Bruce, age 3\nAttributes Attributes are characteristics of an object. A special method called init() is used to initialize the attributes of an object. The Dog class has two attributes (name and age).\nMethods Methods are functions defined inside the body of a class. They are used to perform operations with the attributes of our objects. For example: class Dog: def __init__(self, name, age): self.name = name self.age = age def bark(self): print(self.name + \u0026#39;is barking\u0026#39;)# Dog1 = Dog(\u0026#39;Bruce\u0026#39;) Dog1.bark() This will output: Bruce is barking\n"},{"id":3,"href":"/dit11/appdev/layouts/floatlayout/","title":"Float Layout","parent":"Kivy Layout Types","content":" A FloatLayout with a Button What we are going to do now is write code that uses a FloatLayout with a text input and a custom button in it. To demonstrate how the properties used for sizing and positioning work, though, let’s use just the button first.\nThe size_hint and pos_hint Properties This time we’re going to use the size_hint property instead of size to set the widget size.\nSuppose the button should occupy 30% of the window in horizontal direction and 10% in vertical direction. These percentages should be expressed as .3 and .1 respectively.\nWe’re also going to use the pos_hint property instead of pos. The pos_hint property must be assigned a dictionary\nwith the x, right, y and top values specified. Naturally only up to two of them should be specified at any given time:\nx or right for the horizontal position and y or top for the vertical position.\nThe x, right, y and top Properties What are the four properties?\nx – the left border of the widget\nright – the right border of the widget\ny – the bottom border of the widget\ntop – the top border of the widget\nThe values for each of the properties above is in the range from 0 to 1.\nFor example, if x is set to 0, it means the left border, if it’s set to 1, it means the right border and if it’s set to .3, it’s 30% into the window from the left border. The other properties work the same.\nTo make it clearer, let’s use different combinations of the size_hint and pos_hint properties. If you run the program after each change, you will quickly see how they work.\nThe content of the FloatLayout will be defined in the kv file, so in the Python file we’re only going to return a FloatLayout without bothering what there is in it. This is why the Python file will be the same for each of the examples below. What is going to change is the kv file. So, the Python file is here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import kivy from kivy.app import App from kivy.uix.button import Button # We\u0026#39;ll be using the FloatLayout, so we have to import it. from kivy.uix.floatlayout import FloatLayout class HelloWorldApp(App): def build(self): # Now we\u0026#39;re going to return a FloatLayout. We\u0026#39;ll define it # in the kv file. return FloatLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() Widget Size Let’s start with some basic examples. In the first couple examples we’re not going to bother with position, we’re only going to set the widget size. This means the default position will be assigned, which is the lower left corner.\nSetting the Widget Size with the size_hint Property Here’s the first kv snippet: # File name: helloworld.kv # Here\u0026#39;s our FloatLayout class \u0026lt;FloatLayout\u0026gt;: Button: text: \u0026#39;Press Me\u0026#39; # The button should occupy 50% of the window in both horizontal # and vertical direction. size_hint: .5, .5 Run the program now and you will see that the button indeed occupies 50% of the screen in each direction: Notice that even if you resize the window, the button will still occupy 50% of it in each direction: And now we want the button to occupy the whole width of the window and 30% of its height: # File name: helloworld.kv \u0026lt;FloatLayout\u0026gt;: Button: text: \u0026#39;Press Me\u0026#39; # The button should occupy 100% of the window in horizontal # direction and 30% in vertical direction. size_hint: 1, .3 And here’s the app window: Again, try resizing the window and you will see that regardless of its size, the button will always occupy the whole width and 30% of the height.\nFinally let’s make the button fill the whole window. Actually it will fill the whole FloatLayout, which itself fills the whole window. Here’s the code: # File name: helloworld.kv \u0026lt;FloatLayout\u0026gt;: Button: text: \u0026#39;Press Me\u0026#39; # The button should occupy 100% of the window in both directions. size_hint: 1, 1 And here’s our app window: Setting the Widget Size with the size_hint_x and size_hint_y Properties The size_hint property is set to a tuple of two values, one for scaling in horizontal and the other in vertical direction. But sometimes you may want to scale a widget in just one direction. Then you can use the size_hint_x or size_hint_y property, depending on which direction you need. Let’s scale the button only in horizontal direction first: # File name: helloworld.kv \u0026lt;FloatLayout\u0026gt;: Button: text: \u0026#39;Press Me\u0026#39; # Scale the button only in horizontal direction. It should always # occupy 80% of the width of the window. size_hint_x: .8\nAnd here’s how it looks: And now let’s scale it only in vertical direction: # File name: helloworld.kv \u0026lt;FloatLayout\u0026gt;: Button: text: \u0026#39;Press Me\u0026#39; # Scale the button only in vertical direction. It should always # occupy 15% of the height of the window. size_hint_y: .15\nHere’s the app running: Widget Position Now that you know how to scale the widget, let’s experiment with its position. As you know, the default position is at the coordinates 0, 0, which is at the lower left corner. Now let’s try out all the four properties that we listed before: x, right, y and top. We’re even going to learn two more properties in a minute.\nHorizontal Positioning Let’s start with horizontal positioning. Vertical positioning works pretty much the same, as you will see a bit later.\nThe x Property Anyway, let’s modify our kv file so that there are three buttons. We want each button to have the same size, so we can define a custom button. Here’s the code with x set to 0, .5 and 1. Remember that x is the left border of the widget, so the left border of the button in our case. If you don’t set either the y or the top property, vertical position will default to y = 0.\n# File name: helloworld.kv \u0026lt;CustomButton@Button\u0026gt;: # We want each button to occupy 20% in horizontal direction # and 10% in vertical direction. size_hint: .2, .1 \u0026lt;FloatLayout\u0026gt;: CustomButton: text: \u0026#39;Button 1\u0026#39; # left border of the button on the left pos_hint: {\u0026#39;x\u0026#39;: 0} CustomButton: text: \u0026#39;Button 2\u0026#39; # left border of the button in the middle of the width of the container pos_hint: {\u0026#39;x\u0026#39;: .5} CustomButton: text: \u0026#39;Button 3\u0026#39; # left border of the button on the right border of the container pos_hint: {\u0026#39;x\u0026#39;: 1} If you now run the program, this is what you get: x value outside the range from 0 to 1 If you set x to a value outside the range from 0 to 1, the button or part of it will be outside the window. By setting it to a negative value, the button will be moved to the left. If you set it to a number greater than 1, it will be moved to the right. Finally, by setting it to a number close to 1, the right part of the button will be outside the window, etc. Have a look:\n# File name: helloworld.kv \u0026lt;CustomButton@Button\u0026gt;: size_hint: .2, .1 \u0026lt;FloatLayout\u0026gt;: CustomButton: text: \u0026#39;Button 1\u0026#39; # the whole button outside the window on the left pos_hint: {\u0026#39;x\u0026#39;: -2} CustomButton: text: \u0026#39;Button 2\u0026#39; # left part of the button outside the window on the left pos_hint: {\u0026#39;x\u0026#39;: -.1} CustomButton: text: \u0026#39;Button 3\u0026#39; # right part of the button outside the window on the right pos_hint: {\u0026#39;x\u0026#39;: .9} And here’s what you get if you run the program: The center_x and right Properties Now, suppose we want the buttons to be positioned uniformly: Button 1 on the left, Button 2 in the middle and Button 3 on the right. This would be difficult to achieve with just the x property, because you would have to take into consideration the width of the button to calculate the position of its center and right border. This is where two other properties come in handy: the aforementioned right property for the right border of the widget and the center_x property for the center of the widget in horizontal direction. Let’s see how we can use them:\n# File name: helloworld.kv \u0026lt;CustomButton@Button\u0026gt;: size_hint: .2, .1 \u0026lt;FloatLayout\u0026gt;: CustomButton: text: \u0026#39;Button 1\u0026#39; # This button should be on the left. pos_hint: {\u0026#39;x\u0026#39;: 0} CustomButton: text: \u0026#39;Button 2\u0026#39; # This button should be in the middle, so let\u0026#39;s use the center_x property. pos_hint: {\u0026#39;center_x\u0026#39;: .5} CustomButton: text: \u0026#39;Button 3\u0026#39; # This button should be on the right, so let\u0026#39;s use the right property. pos_hint: {\u0026#39;right\u0026#39;: 1} Here’s the app when you run it: And just one more example with the center_x and right properties in action: # File name: helloworld.kv \u0026lt;CustomButton@Button\u0026gt;: size_hint: .2, .1 \u0026lt;FloatLayout\u0026gt;: CustomButton: text: \u0026#39;Button 1\u0026#39; # The right border of this button should be near the left # border of the window. Part of the button will be invisible. pos_hint: {\u0026#39;right\u0026#39;: .1} CustomButton: text: \u0026#39;Button 2\u0026#39; # The right border of this button should be at the center of the window. pos_hint: {\u0026#39;right\u0026#39;: .5} CustomButton: text: \u0026#39;Button 3\u0026#39; # The center of this button should be 75% away from the left border # of the window. pos_hint: {\u0026#39;center_x\u0026#39;: .75} And here’s how it looks: Vertical Positioning Now that you understand how the three properties x, center_x and right work, it will be easier to understand how their counterparts in the vertical direction work. These are y, center_y and top. In the following examples we can omit the x, center_x and right properties in the pos_hint dictionary. Then the button will be placed at x = 0, which is the default. Have a look: Positioning in Both Directions Naturally, you can position widgets in both directions at the same time. Then you just have to set two properties in the pos_hint dictionary. here’s an example: # File name: helloworld.kv \u0026lt;CustomButton@Button\u0026gt;: size_hint: .2, .1 \u0026lt;FloatLayout\u0026gt;: CustomButton: text: \u0026#39;Button 1\u0026#39; # The button should be 10% from the left horizontally # and its top should be in the middle vertically. pos_hint: {\u0026#39;x\u0026#39;: .1, \u0026#39;top\u0026#39;: .5} CustomButton: text: \u0026#39;Button 2\u0026#39; # The button should be in the center of the window. pos_hint: {\u0026#39;center_x\u0026#39;: .5, \u0026#39;center_y\u0026#39;: .5} CustomButton: text: \u0026#39;Button 3\u0026#39; # The button should be on the right and 20% above the bottom. pos_hint: {\u0026#39;right\u0026#39;: 1, \u0026#39;y\u0026#39;: .2} And this is what we get: The position properties of the buttons are in distinct colors to help you visualize what goes where.\nWell, these are the basics of scaling and positioning widgets in layouts. But there’s more to it. You can also use the size and pos properties in layouts. In the next part we’ll have a look at some more advanced examples of scaling and positioning widgets in layouts.\n"},{"id":4,"href":"/dit11/gamedev/","title":"Game Development","parent":"11 DigiTech","content":""},{"id":5,"href":"/dit11/appdev/gettingStarted/","title":"Getting Started","parent":"App Development","content":""},{"id":6,"href":"/dit11/appdev/basics/python/","title":"Python","parent":"The Basics","content":"If you are new to Python, here is an good interactive guide you can get started with:\nAposteriori: Introduction to Python\n"},{"id":7,"href":"/dit11/appdev/layouts/screenmanager/","title":"ScreenManager","parent":"Kivy Layout Types","content":" Using more than one screen Watch the following video to learn how you can use more than one screen in your app.\nInclude the following 1 2 from kivy.lang import Builder from kivy.uix.screenmanager import ScreenManager How it fits together "},{"id":8,"href":"/dit11/appdev/gettingStarted/software/","title":"Software","parent":"Getting Started","content":"To start using Kivy to develop apps, you will need to:\nOpen the Company Portal: Find and install Visual Studio Code (NOT Visual Studio Community): Find and install Python (3.9):\nOpen Visual Studio Code and install the Python Extension "},{"id":9,"href":"/dit11/appdev/basics/","title":"The Basics","parent":"App Development","content":""},{"id":10,"href":"/dit11/appdev/api/whatisapi/","title":"What is an API","parent":"API","content":"There are millions of APIs online which provide access to data. Websites like Reddit, Twitter, and Facebook all offer certain data through their APIs.\nTo use an API, you make a request to a remote web server, and retrieve the data you need.\nBut why use an API instead of a static CSV dataset you can download from the web? APIs are useful in the following cases:\nThe data is changing quickly. An example of this is stock price data. It doesn’t really make sense to regenerate a dataset and download it every minute — this will take a lot of bandwidth, and be pretty slow. You want a small piece of a much larger set of data. Reddit comments are one example. What if you want to just pull your own comments on Reddit? It doesn’t make much sense to download the entire Reddit database, then filter just your own comments. There is repeated computation involved. Spotify has an API that can tell you the genre of a piece of music. You could theoretically create your own classifier, and use it to compute music categories, but you’ll never have as much data as Spotify does. In cases like the ones above, an API is the right solution. We’ll be querying a simple API to retrieve data about the International Space Station (ISS). What is an API? An API, or Application Programming Interface, is a server that you can use to retrieve and send data to using code. APIs are most commonly used to retrieve data, and that will be the focus of this beginner tutorial.\nWhen we want to receive data from an API, we need to make a request. Requests are used all over the web. For instance, when you visit any page, your web browser made a request to the web server, which responded with the contents of web page. Making API Requests in Python In order to work with APIs in Python, we need tools that will make those requests. In Python, the most common library for making requests and working with APIs is the requests library. The requests library isn’t part of the standard Python library, so you’ll need to install it to get started.\nIf you use pip to manage your Python packages, you can install requests using the following command:\npip install requests\n1 2 3 4 5 6 7 8 9 10 import kivy from kivy.app import App from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout from kivy.uix.textinput import TextInput from kivy.uix.button import Button from kivy.uix.widget import Widget from kivy.properties import ObjectProperty import requests import json Now that we’ve installed and imported the requests library, let’s start using it.\nMaking Our First API Request There are many different types of requests. The most commonly used one, a GET request, is used to retrieve data. Because we’ll just be working with retrieving data, our focus will be on making ‘get’ requests.\nWhen we make a request, the response from the API comes with a response code which tells us whether our request was successful. Response codes are important because they immediately tell us if something went wrong.\nTo make a ‘GET’ request, we’ll use the requests.get() function, which requires one argument — the URL we want to make the request to. We’ll start by making a request to an API endpoint that doesn’t exist, so we can see what that response code looks like. response = requests.get(\u0026#34;https://api.open-notify.org/astros1.json\u0026#34;)\nThe get() function returns a response object. We can use the response.status_code attribute to receive the status code for our request: print(response.status_code)\n404 The ‘404’ status code might be familiar to you — it’s the status code that a server returns if it can’t find the file we requested. In this case, we asked for this-api-doesnt-exist which (surprise, surprise) didn’t exist!\nLet’s learn a little more about common status codes.\nAPI Status Codes Status codes are returned with every request that is made to a web server. Status codes indicate information about what happened with a request. Here are some codes that are relevant to GET requests:\n200: Everything went okay, and the result has been returned (if any). 301: The server is redirecting you to a different endpoint. This can happen when a company switches domain names, or an endpoint name is changed. 400: The server thinks you made a bad request. This can happen when you don’t send along the right data, among other things. 401: The server thinks you’re not authenticated. Many APIs require login ccredentials, so this happens when you don’t send the right credentials to access an API. 403: The resource you’re trying to access is forbidden: you don’t have the right perlessons to see it. 404: The resource you tried to access wasn’t found on the server. 503: The server is not ready to handle the request. You might notice that all of the status codes that begin with a ‘4’ indicate some sort of error. The first number of status codes indicate their categorization. This is useful — you can know that if your status code starts with a ‘2’ it was successful and if it starts with a ‘4’ or ‘5’ there was an error. If you’re interested you can read more about status codes here. API Documentation In order to ensure we make a successful request, when we work with APIs it’s important to consult the documentation. Documentation can seem scary at first, but as you use documentation more and more you’ll find it gets easier.\nWe’ll be working with the Open Notify API, which gives access to data about the international space station. It’s a great API for learning because it has a very simple design, and doesn’t require authentication. We’ll teach you how to use an API that requires authentication in a later post.\nOften there will be multiple APIs available on a particular server. Each of these APIs are commonly called endpoints. The first endpoint we’ll use is http://api.open-notify.org/astros.json, which returns data about astronauts currently in space.\nIf you click the link above to look at the documentation for this endpoint, you’ll see that it says This API takes no inputs. This makes it a simple API for us to get started with. We’ll start by making a GET request to the endpoint using the requests library: response = requests.get(\u0026#34;https://api.open-notify.org/astros.json\u0026#34;) print(response.status_code)\n200 We received a ‘200’ code which tells us our request was successful. The documentation tells us that the API response we’ll get is in JSON format. In the next section we’ll learn about JSON, but first let’s use the response.json() method to see the data we received back from the API: print(response.json())\n{\u0026#39;message\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;people\u0026#39;: [{\u0026#39;name\u0026#39;: \u0026#39;Alexey Ovchinin\u0026#39;, \u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;Nick Hague\u0026#39;, \u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;Christina Koch\u0026#39;, \u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;Alexander Skvortsov\u0026#39;, \u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;Luca Parmitano\u0026#39;, \u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;Andrew Morgan\u0026#39;, \u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;}], \u0026#39;number\u0026#39;: 6} Working with JSON Data in Python JSON (JavaScript Object Notation) is the language of APIs. JSON is a way to encode data structures that ensures that they are easily readable by machines. JSON is the primary format in which data is passed back and forth to APIs, and most API servers will send their responses in JSON format.\nWe need to import json by adding: 1 2 3 4 5 6 7 8 9 10 import kivy from kivy.app import App from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout from kivy.uix.textinput import TextInput from kivy.uix.button import Button from kivy.uix.widget import Widget from kivy.properties import ObjectProperty import requests import json You might have noticed that the JSON output we received from the API looked like it contained Python dictionaries, lists, strings and integers. You can think of JSON as being a combination of these objects represented as strings. Let’s look at a simple example: Python has great JSON support with the json package. The json package is part of the standard library, so we don’t have to install anything to use it. We can both convert lists and dictionaries to JSON, and convert strings to lists and dictionaries. In the case of our ISS Pass data, it is a dictionary encoded to a string in JSON format.\nThe json library has two main functions:\njson.dumps() — Takes in a Python object, and converts (dumps) it to a string. json.loads() — Takes a JSON string, and converts (loads) it to a Python object. The dumps() function is particularly useful as we can use it to print a formatted string which makes it easier to understand the JSON output, like in the diagram we saw above: 1 2 3 4 5 6 7 8 9 10 11 def btn(self): # GET request to web server for data in json format response = requests.get(\u0026#34;http://api.open-notify.org/astros.json\u0026#34;) # print the status code print(response.status_code) # print the data recieved from the server print(response.json()) # create a formatted string of the Python JSON object text = json.dumps(response.json(), sort_keys=True, indent=4) print(text) Output\n200 {\u0026#39;people\u0026#39;: [{\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Mark Vande Hei\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Pyotr Dubrov\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Anton Shkaplerov\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;Shenzhou 13\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Zhai Zhigang\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;Shenzhou 13\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Wang Yaping\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;Shenzhou 13\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Ye Guangfu\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Raja Chari\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Tom Marshburn\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Kayla Barron\u0026#39;}, {\u0026#39;craft\u0026#39;: \u0026#39;ISS\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Matthias Maurer\u0026#39;}], \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;number\u0026#39;: 10} { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;number\u0026#34;: 10, \u0026#34;people\u0026#34;: [ { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Mark Vande Hei\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Pyotr Dubrov\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Anton Shkaplerov\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;Shenzhou 13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Zhai Zhigang\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;Shenzhou 13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wang Yaping\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;Shenzhou 13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Ye Guangfu\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Raja Chari\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Tom Marshburn\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Kayla Barron\u0026#34; }, { \u0026#34;craft\u0026#34;: \u0026#34;ISS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Matthias Maurer\u0026#34; } ] } Immediately we can understand the structure of the data more easily – we can see that their are ten people currently in space, with their names existing as dictionaries inside a list.\nIf we compare this to the documentation for the endpoint we’ll see that this matches the specified output for the endpoint.\n"},{"id":11,"href":"/dit11/appdev/gettingStarted/helloworld/","title":"1. Hello World","parent":"Getting Started","content":"Taken from prosperocoder.com\nHello World – A Basic Kivy App Well, we’re going to write a basic Kivy app that will display the Hello World text. In Kivy, like in many other GUI libraries and frameworks, static text is usually displayed in a label. In Kivy we call simple GUI elements like labels, buttons, sliders, check boxes, etc. widgets, although widgets don’t have to be simple at all and you can create your own widgets, which we are going to do later.\nCreate a folder Anyway, our program is going to display the text Hello World in a label. Before we write the code, let’s create a folder where we will save it. Then open the folder in your editor or IDE. Here’s how to do it in Visual Studio Code:\nOpen folder in VSC Setup and install Kivy Create a new virtual environment for your Kivy project. A virtual environment will prevent possible installation conflicts with other Python versions and packages. It’s optional but strongly recommended, open a New Terminal window and run the following:\nOpen a Terminal window and create the virtual environment named .env in your current directory: python -m venv .venv Update the security on this folder Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process Activate your new virtual environment. .venv\\scripts\\activate Install Kivy python -m pip install kivy If you get SSL errors use the following to install Kivy etc pip3 install --trusted-host pypi.org --trusted-host files.pythonhosted.org kivy\nCreate a new file When you open your folder, you need a file to write the code to. This is going to be a regular Python file, so with the extension .py. You can name your file whatever you like, I’ll name mine main.py. Here’s how you can create the file: When you hover your mouse over the name of your folder, a menu with a couple icons will appear. The first icon is the one you should click to create a new file:\nOpen folder in VSC All you have to do is type in the name of the file: main.py. As soon as you confirm by hitting Enter, the new file will be listed in the folder (A) and it will open automatically in a new tab (B). This is how we are going to add new files in the future. Open folder in VSC Write the code of the Kivy app Now we are ready to write our code. Here it is with comments: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # We\u0026#39;re using Kivy, so we\u0026#39;ll need the kivy module import kivy # We need the App class. Our application is going to inherit from it. from kivy.app import App # We also need the Label widget. from kivy.uix.button import Label # Here comes the application class. It inherits from App. class HelloWorldApp(App): def build(self): return Label(text=\u0026#39;Hello World!\u0026#39;) # And this is where we actually run the app. if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() Running Your Kivy App This is a basic Kivy application. Now we are ready to run it. There are several ways you can do it. Let’s have a look at the most obvious ones:\n1) the Run Python File in Terminal button The first way to run the app is by pressing the Run Python File in Terminal button in the upper right corner (A). Here’s what we get when we do that: the application window shows up with our application running in it (B) and the terminal opens at the bottom with the Kivy log (C). Run Python File in Terminal button 2) Run the Kivy App Without Debugging in the Debug menu You can also go to the Debug menu and select Run Without Debugging: Run the Kivy App Without Debugging 3) Start Debugging option in the Debug menu There is also the Start Debugging option in the Debug menu. You can choose it and then select a Debug Configuration. Go ahead and select the first option, Python File: Start Debugging option in the Debug menu 4) Hotkeys For the previous two options you can also use hotkeys:\n– F5 to start debugging – Ctrl + F5 to run without debugging 5) Context menu You can also right-click anywhere in the editor tab where the code of your file is and select Run Python File in Terminal: Context menu "},{"id":12,"href":"/dit11/appdev/gettingStarted/kvfiles/","title":"2. Kv Files","parent":"Getting Started","content":"Taken from prosperocoder.com\nOur program contains just one widget, the label. This is all as far as presentation is concerned. We’ll move that part to a new file and leave the rest in the main.py file. So, after we remove the presentation part from the main.py, as well as the comments to make the file clear and transparent, this is what we’ll have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # We\u0026#39;re using Kivy, so we\u0026#39;ll need the kivy module import kivy # We need the App class. Our application is going to inherit from it. from kivy.app import App # We also need the Label widget. from kivy.uix.button import Label # Here comes the application class. It inherits from App. class HelloWorldApp(App): def build(self): return Label() # And this is where we actually run the app. if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() As you can see, now we’re just telling the app that a label should be used, but it doesn’t know anything more about the label. In particular, it doesn’t know what text should go in the label. This is what the kv file is going to take care of. By the way, I’m going to call the files written in the Kivy language kv files, for the sake of brevity. These files are easily recognizable by the kv extension.\nkv Files and the Kivy Language Now we are ready to create the kv file. Actually, there are two approaches to this. If you have just one kv file, you can go with the simpler approach.\nNaming Convention In this approach we use a naming convention according to which we name the file the same as the app class (the class that inherits from App), but without the ‘App’ part and all lowercase. So, in our example the app class is HelloWorldApp, so the kv file should be named helloworld.kv.\nNow, in Visual Studio Code (which I’m going to refer to as VSC from now on, also for brevity’s sake), create a new file, just as you did before and name it helloworld.kv:\nOpen folder in VSC As soon as you hit Enter, the file will open in a new tab. Type the following Kivy language code: 1 2 \u0026lt;Label\u0026gt;: text: \u0026#39;Hello World!\u0026#39; We’re going to talk about the Kivy language in more detail later on, for now it’s enough to say that this is all you need to take care of the label. The : part means we’re working on the Label class, and below we set the text property to a string of our choice.\nNow save the kv file and go back to the main.py. Run the program. This is what you should see: "},{"id":13,"href":"/dit11/appdev/gettingStarted/labels/","title":"3. Label Properties","parent":"Getting Started","content":"Taken from prosperocoder.com\nHere’s the code again.\nThe Python file:\n1 2 3 4 5 6 7 8 9 10 11 12 File name: main.py import kivy from kivy.app import App from kivy.uix.button import Label class HelloWorldApp(App): def build(self): return Label() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() and the kv file: 1 2 3 4 # File name: helloworld.kv \u0026lt;Label\u0026gt;: text: \u0026#39;Hello World!\u0026#39; This program displays a label. The label has a text property. This is a special Kivy property, not to be confused with the regular Python property. We’re going to use Kivy properties a lot, and even create our own ones, just bear with me. Anyway, the Label class has some more properties. We’re going to have a look at the Label properties in this part and then in the next part we’ll see how to use other widgets like buttons, toggle buttons, check boxes, text inputs and sliders, both in Python and in the Kivy language. These are the widgets we’ll be making use of in our project, but there many others, which you can look up in the documentation, which you can find at kivy.org.\nAnd now let’s have a closer look at the Label class and the Label properties. You already know the text property. It’s used to set the actual text you want to display. By the way, you probably noticed that the name of a property is followed by a colon and then comes the value we want to set the property to. This same syntax is valid for all the other properties.\nOther Label Properties – The font_size Property The next property I’d like to mention is font_size. The name is pretty self-explanatory, let me just add that the value is in pixels. Let’s add this property to the code in our helloworld.kv file: 1 2 3 4 \u0026lt;Label\u0026gt;: text: \u0026#39;Hello World!\u0026#39; font_size: 50 If you now run the program (you must go to the main.py tab first), the label displayed in the window will be much bigger than before.\nOther Label Properties – The color Property There’s another property for the color of the text, called color to make things more interesting. What is really interesting about this property, however, is its value, which is a list with four elements: r(ed), g(reen), b(lue) and a(lpha). The default value is [1, 1, 1, 1], which corresponds to fully opaque white. The values for each component are in the range from 0 to 1, which probably is not exactly what you are used to. In a lot of frameworks the values of r, g, b and a are from 0 to 255. Here, it is your task to recalculate the values so that they fit in the 0-1 range. Just keep in mind that 0 is the same in both ranges and 255 in the traditional scale corresponds to 1 in kv. So, if you want the color to be a shade of purple where the values are:\nr = 126\ng = 45\nb = 210\na = 255\nyou can either calculate the kv values manually like so:\nr = 126/255 ≈ 0.56\ng = 45/255 ≈ 0.18\nb = 210/255 ≈ 0.82\na = 255/255 = 1\nor type the operations directly in the list. So, in our case you could set the color like so: color: [.56, .18, .82, 1] or like so: color: [126/255, 45/255, 210/255, 1] You can use whichever you like. I like the second one better because I’m used to the 0-255 range, but I’m going to use them interchangeably throughout the project so that you get used to both of them. Now the full kv code is: \u0026lt;Label\u0026gt;: text: \u0026#39;Hello World!\u0026#39; font_size: 50 color: [126/255, 45/255, 210/255, 1] and if you run the program (from main.py), this is what you will get: Font size Text Markup There are lots of other properties that you can use with the Label class. Some of them will be used in the project and I’ll talk a little more about them when you need them. There is however one very interesting property that we are not going to use in the app, and which is definitely worth mentioning, that’s why I’d like to tell you something about it now.\nYou can style your text using text markup. This is very similar to what you may be familiar with if you know some HTML, however instead of angled brackets (\u0026lt;\u0026gt;, \u0026lt;/\u0026gt;) we use square brackets in kv ([ ], [/]). Just like in HTML there’s an opening tag and a closing tag, as you can see.\ntags There are lots of tags available. Let’s have a look at just a small selection:\n[b][/b] – bold text\n[i][/i] – italic text\n[u][/u] – underlined text\n[s][/s] – strikethrough text\n[sub][/sub] – subscript text\n[sup][/sup] – superscript text\n[size=][/size] – font size\n[color=#][/color] – text color\nThe markup Property In order to use text markup, you must add one more property, markup, and set it to True. Let’s now change the text to something longer than Hello World and try the markup tags out. Here’s the code: \u0026lt;Label\u0026gt;: text: \u0026#39;normal [b]bold[/b] [i]italic[/i] \\n[u]underlined[/u] [s]strikethrough[/s] \\n[sub]subscript[/sub] [sup]superscript[/sup] [size=100]big[/size] [color=#ff0f]yellow[/color]\u0026#39; font_size: 50 color: [126/255, 45/255, 210/255, 1] markup: True Two things to keep in mind:\nFirst, the value of the text property, which is the string, should be all on a single line.\nSecond, in text markup we use hex values for colors, so if the rgba for yellow is 255, 255, 0, 255 (fully opaque), then its hexadecimal representation is ff0f, which you can see in the color tag. Now run the program and you should get something like this: Font size We’ve been working with just one basic widget so far, the label. But there are lots of other useful widgets, like buttons, toggle buttons, check boxes, text inputs, sliders and many, many more. We’re going to use some of them in our application, so in the following parts I’ll show you some of the widgets that we’re going to use and some of their most important properties.\n"},{"id":14,"href":"/dit11/appdev/gettingStarted/buttons/","title":"4. Buttons","parent":"Getting Started","content":"Taken from prosperocoder.com\nA Button Widget is Basically a Label… In Kivy the Button class inherits from Label, so they have the same properties in common, plus the button has some extra functionality. In particular they share the text property. Let’s modify our main.py and helloworld.kv files so that our program displays a button widget instead of a label. First, let the changes be as few as possible. Here’s the main.py file:\n# File name: main.py import kivy from kivy.app import App # We\u0026#39;re not importing Label anymore. #from kivy.uix.button import Label # Instead we\u0026#39;re importing Button from kivy.uix.button import Button class HelloWorldApp(App): def build(self): # We don\u0026#39;t want to return a label, but rather... #return Label() # a button return Button() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() and here’s the kv file:\n# File name: helloworld.kv # Let\u0026#39;s just change Label to Button. \u0026lt;Button\u0026gt;: text: \u0026#39;normal [b]bold[/b] [i]italic[/i] \\n[u]underlined[/u] [s]strikethrough[/s] \\n[sub]subscript[/sub] [sup]superscript[/sup] [size=100]big[/size] [color=#ff0f]yellow[/color]\u0026#39; font_size: 50 color: [126/255, 45/255, 210/255, 1] markup: True Again, the whole string in the text property should be on one line. Anyway, this code is exactly the same as we left off at in the previous part except for one detail: now we have the Button class instead of Label. Run this code and the output will be very much like before. But this time the whole window is filled with our big button with lots of formatted text on it. If it’s a button, you can click it. Give it a try and you will see that it changes color when clicked. Naturally nothing else is going to happen because there isn’t any code yet that would handle the button click. But we now have a fully functional button: How About a Button Widget that Looks More Like a Button? What we just saw is definitely a button, although usually we don’t put so much text on a button. We don’t format the text on a button in such a way either. Let’s simplify our button a bit so that it looks more like a button you’re used to. Let’s say we want the button text to read: ‘Click here’, without any markup formatting or any fancy colors. Here’s the modified code that will give us a simple button. The main.py file remains untouched, I just cleared it up a little by removing the comments: # File name: main.py import kivy from kivy.app import App from kivy.uix.button import Button class HelloWorldApp(App): def build(self): return Button() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And now the kv file: # File name: helloworld.kv \u0026lt;Button\u0026gt;: text: \u0026#39;Click here\u0026#39; font_size: 50 If you now run this code, the button will look more familiar. It’s still going to fill up all the available space, because it’s the only widget for the time being.\nBasic Button Events Why do we even use buttons instead of labels? Well, as mentioned before, they have some extra functionality. They can be clicked, or pressed, as you just saw. I’m going to talk about events in Kivy a bit later, but as we are at it, let’s just see how to handle pressing the button directly in kv. For more advanced scenarios, we’ll be handling events in Python code later on.\nSo, let’s say we want the font size to be 100 instead the original 50 when the button is pressed. The main.py code remains the same, but in kv we just add the code that will handle the press event: \u0026lt;Button\u0026gt;: text: \u0026#39;Click here\u0026#39; font_size: 50 # You should use self to refer to the Button object itself. # So, self.text refers to the text property on the Button object # and self.font_size refers to the Button object\u0026#39;s font_size property. on_press: self.font_size = 100 If you now run the program and press the button, the font size will be changed. The problem with this code is that the font_size doesn’t change back after you release the button. Fortunately there’s an easy way to fix it. All you have to do is tell the program what to do when the button is released: # File name: helloworld.kv \u0026lt;Button\u0026gt;: text: \u0026#39;Click here\u0026#39; font_size: 50 on_press: self.font_size = 100 on_release: self.font_size = 50 Now it will work as expected, but don’t take my word for it.\nMultiple Commands And now suppose we want the button not only to resize its font when pressed, but also to change the text to ‘pressed’. When released, the font_size should be set back to 50 and the text should change to ‘Click again’. You can do it in two ways. The first way is just to add as many on_press and on_release lines as needed: # File name: helloworld.kv \u0026lt;Button\u0026gt;: text: \u0026#39;Click here\u0026#39; font_size: 50 on_press: self.font_size = 100 on_press: self.text = \u0026#39;pressed\u0026#39; on_release: self.font_size = 50 on_release: self.text = \u0026#39;Click again\u0026#39; The second, more concise way is to separate the commands by semicolons: \u0026lt;Button\u0026gt;: text: \u0026#39;Click here\u0026#39; font_size: 50 on_press: self.font_size = 100; self.text = \u0026#39;pressed\u0026#39; on_release: self.font_size = 50; self.text = \u0026#39;Click again\u0026#39; Either way you choose, the result will be the same: Adding Events Like most GUI toolkits, Kivy is mostly event-based. The framework responds to user keypresses, mouse events, and touch events. Kivy has the concept of a Clock that you can use to schedule function calls for some time in the future.\nKivy also has the concept of Properties, which works with the EventDispatcher. Properties help you do validation checking. They also let you fire events whenever a widget changes its size or position.\n1 2 3 4 5 6 7 8 9 10 11 12 13 from kivy.app import App from kivy.uix.button import Button class ButtonApp(App): def build(self): return Button() def on_press_button(self): print(\u0026#39;You pressed the button!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app = ButtonApp() app.run() This code might look a bit odd at first glance, as it creates a Button without setting any of its attributes or binding it to any events. What’s happening here is that Kivy will automatically look for a file that has the same name as the class in lowercase, without the App part of the class name.\nIn this case, the class name is ButtonApp, so Kivy will look for a file named button.kv. If that file exists and is properly formatted, then Kivy will use it to load up the UI. Go ahead and create this file and add the following code: 1 2 3 4 5 6 \u0026lt;Button\u0026gt;: text: \u0026#39;Press me\u0026#39; size_hint: (.5, .5) pos_hint: {\u0026#39;center_x\u0026#39;: .5, \u0026#39;center_y\u0026#39;: .5} on_press: app.on_press_button() Here’s what each line does:\nLine 1 matches the Button call in your Python code. It tells Kivy to look into the instantiated object for a button definition. Line 2 sets the button’s text. Line 3 sets the width and height with size_hint. Line 4 sets the button’s position with pos_hint. Line 5 sets the on_press event handler. To tell Kivy where the event handler is, you use app.on_press_button(). Here, Kivy knows will look in the Application class for a method called .on_press_button(). You can set up all of your widgets and layouts inside one or more KV language files. The KV language also supports importing Python modules in KV, creating dynamic classes, and much more. For full details, check out Kivy’s guide to the KV Language.\n"},{"id":15,"href":"/dit11/appdev/layouts/","title":"Kivy Layout Types","parent":"App Development","content":"Layouts are containers used to arrange widgets in a particular manner.\nAnchor Layout: Widgets can be anchored to the ‘top’, ‘bottom’, ‘left’, ‘right’ or ‘center’.\nBox Layout: Widgets are arranged sequentially, in either a ‘vertical’ or a ‘horizontal’ orientation.\nFloat Layout: Widgets are essentially unrestricted.\nRelative Layout: Child widgets are positioned relative to the layout.\nGrid Layout: Widgets are arranged in a grid defined by the rows and cols properties.\nPage Layout: Used to create simple multi-page layouts, in a way that allows easy flipping from one page to another using borders.\nScatter Layout: Widgets are positioned similarly to a RelativeLayout, but they can be translated, rotated and scaled.\nStack Layout: Widgets are stacked in a lr-tb (left to right then top to bottom) or tb-lr order.\nWhen you add a widget to a layout, the following properties are used to determine the widget’s size and position, depending on the type of layout:\nsize_hint: defines the size of a widget as a fraction of the parents size. Values are restricted to the range 0.0 - 1.0 i.e. 0.01 = 1/100th of the parent size (1%) and 1. = same size (100%).\npos_hint: is used to place the widget relative to the parent.\nThe size_hint and pos_hint are used to calculate a widget’s size and position only if the value(s) are not set to None. If you set these values to None, the layout will not position/size the widget and you can specify the values (x, y, width, height) directly in screen coordinates.\n"},{"id":16,"href":"/dit11/appdev/layouts/pagelayouts/","title":"Page Layouts","parent":"Kivy Layout Types","content":"The PageLayout works in a different manner from other layouts. It is a dynamic layout, in the sense that it allows flipping through pages using its borders. The idea is that its components are stacked in front of each other, and we can just see the one that is on top. PageLayout is similar to pages of a copy like that we can move/change the pages right or left.\nThe PageLayout class is used to create a simple multi-page layout, in a way that allows easy flipping from one page to another using border.\nTo use PageLayout you have to import it by the below command: from kivy.uix.pagelayout import PageLayout Note: PageLayout does not currently honor the size_hint, size_hint_min, size_hint_max, or pos_hint properties. That means we can not use all these in a page layout. Example:\nPageLayout: Button: text: \u0026#39;page1\u0026#39; Button: text: \u0026#39;page2\u0026#39; Button: text: \u0026#39;page3\u0026#39;\nTransitions from one page to the next are made by swiping in from the border areas on the right or left-hand side. If you want to use multiple widgets on a page, use layouts to do that. Ideally, each page should consist of a single layout widget that contains the remaining widgets on that page.\nPage Layout contains many things which can be used to make it more effective easily in .kv file.\nborder: The width of the border around the current page used to display the previous/next page swipe areas when needed. border is a NumericProperty and defaults to 50dp. page: The currently displayed page. Page is a NumericProperty and defaults to 0. swipe_threshold: The threshold used to trigger swipes as percentage of the widget size. swipe_threshold is a NumericProperty and defaults to .5. Basic Approach to create page layout using .kv file\nimport kivy import kivyApp import Pagelayout Set minimum version(optional) create Layout class create App class create build() function Set up .kv file(name same as the App class) return Layout/widget/Class(according to requirement) Run an instance of the class Below is the Implementation for .kv files in this code :\n1). kv file is just Simply how to create pages in .kv file 2). kv file is how can yo add features like : color, text, image, canvas, swipe_threshold, button in the pages.\nImplementation of the Approach – main.py file\n## Sample Python application demonstrating the ## working of PageLayout in Kivy using .kv file ################################################## # import kivy module import kivy # base Class of your App inherits from the App class. # app:always refers to the instance of your application from kivy.app import App # this restrict the kivy version i.e # below this kivy version you cannot # use the app or software kivy.require(\u0026#39;1.9.0\u0026#39;) # The PageLayout class is used to create # a simple multi-page layout, # in a way that allows easy flipping from # one page to another using borders. from kivy.uix.pagelayout import PageLayout # creating the root widget used in .kv file class PageLayout(PageLayout): pass # creating the App class in which name #.kv file is to be named PageLayout.kv class PageLayoutApp(App): # defining build() def build(self): # returning the instance of root class return PageLayout() # creating object of PageLayoutApp() class plApp = PageLayoutApp() # run the class plApp.run() .kv file of Simple pages # creating simple Pagelayout using.kv \u0026lt;PageLayout\u0026gt;: # creating Page 1 Button: text: \u0026#34;Page 1\u0026#34; # creating Page 2 Button: text: \u0026#34;Page 2\u0026#34; # creating Page 3 Button: text: \u0026#34;Page 3\u0026#34; # creating Page 3 Button: text: \u0026#34;Page 4\u0026#34; # create Page as may as you want Output: Lets modify the .kv file to include more widgets on each page # creating simple Pagelayout using.kv # creating page Layout \u0026lt;PageLayout\u0026gt;: # creating simple Pagelayout using.kv # creating page Layout \u0026lt;PageLayout\u0026gt;: # Creating Page 1 # Using BoxLayout inside PageLayout BoxLayout: # creating Canvas canvas: Color: rgb: 0, .5, .95, 1 Rectangle: pos: self.pos size: self.size # Providing orientation to the BoxLayout orientation: \u0026#34;vertical\u0026#34; # creating Button Button: text: \u0026#34;Page 1\u0026#34; size_hint_y: .4 # Adding Label to Page 1 Label: markup: True text: \u0026#34;[b]This is a label[/b]\u0026#34; color: 0, 0, 0, 1 outline_color: 0, 0.5, 0.5, 1 font_size: 30 # Creating Page 2 BoxLayout: orientation: \u0026#34;vertical\u0026#34; canvas: Color: rgba: 109 / 255., 8 / 255., 57 / 255., 1 Rectangle: pos: self.pos size: self.size Label: markup: True text: \u0026#34; Kivy[b]PageLayout[/b]!!!!! \u0026#34; color: 0, 0, 0, 1 outline_color: 0, 0.5, 0.5, 1 font_size: 30 Button: text: \u0026#34;Page 2\u0026#34; size_hint_y: .2 # Creating Page 3 BoxLayout: orientation: \u0026#39;vertical\u0026#39; canvas: Color: rgba: 100 / 555., 9 / 155., 37 / 455., 1 Rectangle: pos: self.pos size: self.size Label: text: \u0026#39;page 3\u0026#39; # This Image is directly from the websource # By using AsyncImage you can use that AsyncImage: source: \u0026#39;http://kivy.org/logos/kivy-logo-black-64.png\u0026#39; # Creating Page 4 Button: # Adding image # image must be .png # and present at the same folder where # .kv and main file is saved Image: source: \u0026#34;image-129.png\u0026#34; center_x: self.parent.center_x center_y: self.parent.center_y "},{"id":17,"href":"/dit11/appdev/api/parsejson/","title":"Parse JSON","parent":"API","content":" What is Parsing Parsing is breaking a block of data into smaller pieces (tokens) by following a set of rules (using delimiters for example), so that this data could be processes piece by piece (managed, analysed, interpreted, transmitted, ets).\nHow do we parse JSON in Python. First we load a JSON file using json.load() method. The result is a Python dictionary. We can then access the fields using dictionary methods.\nJSON is a lightweight data-interchange format.\nTo extract information from a JSON file or a JSON response, we have to parse the data.\nParse JSON in Python Convert JSON to a Python Dictionary It’s a good idea to convert JSON to a Python dictionary when you want to use the data in your code because this lets you access all of the supporting functions dictionary objects offer in Python. The next example uses json.loads() to convert the JSON into a Python dictionary. It then uses a few of the built in functions of the dictionary object and prints the results to the console:\nWe will use the following JSON in our example:\n{ \u0026#34;orders\u0026#34;: [ { \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;price\u0026#34;: 15.67, \u0026#34;toppings\u0026#34;: [\u0026#34;mushrooms\u0026#34;, \u0026#34;pepperoni\u0026#34;, \u0026#34;basil\u0026#34;], \u0026#34;extra_cheese\u0026#34;: false, \u0026#34;delivery\u0026#34;: true, \u0026#34;client\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;email\u0026#34;: \u0026#34;janedoe@email.com\u0026#34; } }, { \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;price\u0026#34;: 6.54, \u0026#34;toppings\u0026#34;: null, \u0026#34;extra_cheese\u0026#34;: true, \u0026#34;delivery\u0026#34;: false, \u0026#34;client\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo Jones\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;556-342-452\u0026#34;, \u0026#34;email\u0026#34;: null } } ] } Please take a moment to analyze the structure of this JSON file.\nHere are some quick tips:\nNotice the data types of the values, the indentation, and the overall structure of the file. The value of the main key \u0026ldquo;orders\u0026rdquo; is an array of JSON objects (this array will be represented as list in Python). Each JSON object holds the data of a pizza order. If we want to read this file in Python, we just need to read and create a dictionary with the statement: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def jsonpractice(self): file = \u0026#34;\u0026#34;\u0026#34;{ \u0026#34;orders\u0026#34;: [ { \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;price\u0026#34;: 15.67, \u0026#34;toppings\u0026#34;: [\u0026#34;mushrooms\u0026#34;, \u0026#34;pepperoni\u0026#34;, \u0026#34;basil\u0026#34;], \u0026#34;extra_cheese\u0026#34;: false, \u0026#34;delivery\u0026#34;: true, \u0026#34;client\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;email\u0026#34;: \u0026#34;janedoe@email.com\u0026#34; } }, { \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;price\u0026#34;: 6.54, \u0026#34;toppings\u0026#34;: null, \u0026#34;extra_cheese\u0026#34;: true, \u0026#34;delivery\u0026#34;: false, \u0026#34;client\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo Jones\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;556-342-452\u0026#34;, \u0026#34;email\u0026#34;: null } } ] } \u0026#34;\u0026#34;\u0026#34; data = json.loads(file) json.loads(file) creates and returns a new Python dictionary with the key-value pairs in the JSON file.\nOnce we have the content of the JSON file stored in the data variable as a dictionary, we can use it to do basically anything we want.\nExamples For example, if we write:\nprint(len(data[\u0026#34;orders\u0026#34;])) The output is 2 because the value of the main key \u0026ldquo;orders\u0026rdquo; is a list with two elements.\nWe can also use the keys to access their corresponding values. This is what we typically do when we work with JSON files.\nFor example, to access the toppings of the first order, we would write: data[\u0026#34;orders\u0026#34;][0][\u0026#34;toppings\u0026#34;]\nFirst, we select the main key \u0026ldquo;orders\u0026rdquo; Then, we select the first element in the list (index 0). Finally, we select the value that corresponds to the key \u0026ldquo;toppings\u0026rdquo; You can see this \u0026ldquo;path\u0026rdquo; graphically in the diagram: If we print this value, the output is: [\u0026#39;mushrooms\u0026#39;, \u0026#39;pepperoni\u0026#39;, \u0026#39;basil\u0026#39;]\nLet\u0026rsquo;s look at some live weather data There are 1000s of APIs for use in software and web development on a variety of topics including sport, jokes, bitcoin etc. Before you can start using an API you need to first need to read the API Documentation to understand what parameters need to be used.\nIn this example we are using a free weather API that doesn\u0026rsquo;t require an authentication key and just needs {location} to be replaced.\nhttps://weatherdbi.herokuapp.com/data/weather/{location} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def btn(self): #Set the location we are looking for location = \u0026#34;Adelaide\u0026#34; # GET request to web server for data in json format and add the location to the end response = requests.get(\u0026#34;https://weatherdbi.herokuapp.com/data/weather/\u0026#34; + location) # print the data recieved from the server print(response.json()) # create a formatted string of the Python JSON object text = json.dumps(response.json(), sort_keys=True, indent=4) print(text) print(\u0026#34;---------------------------------------------------\u0026#34;) # convert the JSON file into a Python dictionary to extract data json_data = json.loads(response.text) # print the current temperature of the location in degrees celsius print(json_data[\u0026#34;currentConditions\u0026#34;][\u0026#34;temp\u0026#34;][\u0026#34;c\u0026#34;]) todays_temp = json_data[\u0026#34;currentConditions\u0026#34;][\u0026#34;temp\u0026#34;][\u0026#34;c\u0026#34;] print(\u0026#34;Current temperature is \u0026#34; + str(todays_temp)) What other data can you display from the API? Now show it on your APP! "},{"id":18,"href":"/dit11/appdev/layouts/morelayouts/","title":"More Layouts","parent":"Kivy Layout Types","content":" Relative Layout RelativeLayout works pretty much like FloatLayout and the difference will be clear only later when we embed it in another layout. Here’s a simple example with a RelativeLayout and just one button in it. The button should be positioned at the fixed coordinates 0, 0 and occupy about a third of the available space in both horizontal and vertical direction.\nHere’s the Python code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import kivy from kivy.app import App # We must import the RelativeLayout class. from kivy.uix.relativelayout import RelativeLayout class HelloWorldApp(App): def build(self): # We\u0026#39;re going to use the RelativeLayout now. return RelativeLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And here’s the kv file: # File name: helloworld.kv \u0026lt;RelativeLayout\u0026gt;: Button: text: \u0026#39;Button\u0026#39; size_hint: .3, .3 pos: 0, 0 If you run this code you’ll see something you would also see using the FloatLayout:\nSo, what’s the difference? As mentioned before, you will see the difference soon. And now let’s move on to the next layout, the GridLayout.\nGridLayout To demonstrate how a GridLayout works we’ll need more than one widget in it. Let’s create five buttons this time. Here the Python code:\nimport kivy from kivy.app import App # We must import the GridLayout class. from kivy.uix.gridlayout import GridLayout class HelloWorldApp(App): def build(self): # We\u0026#39;re going to use the GridLayout now. return GridLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() GridLayout rows Now, with a GridLayout we must set the number of either rows or columns. The two properties that we use for that are rows and cols. Then the available space will be filled in gradually so that the predefined number of rows or columns is maintained, but let me show it on a example. First suppose we want the buttons to be in a grid consisting of two rows. Here’s the kv code: # File name: helloworld.kv \u0026lt;GridLayout\u0026gt;: # We need two rows. rows: 2 # And now come the buttons. Button: text: \u0026#39;Button 1\u0026#39; size_hint: None, None size: 200, 50 Button: text: \u0026#39;Button 2\u0026#39; size_hint: None, None size: 200, 50 Button: text: \u0026#39;Button 3\u0026#39; size_hint: None, None size: 200, 50 Button: text: \u0026#39;Button 4\u0026#39; size_hint: None, None size: 200, 50 Button: text: \u0026#39;Button 5\u0026#39; size_hint: None, None size: 200, 50\nNow, a few remarks about the code. First of all watch how I set size_hint to (None, None). This is because I wanted fixed numbers for pixels, each button being 200 x 50 pixels. You already know how it works from the previous part. The second thing you notice is that the code is very repetitive. If you now wanted to change the size of the button, you’d have to do it five times. So, let’s rewrite the code so that we avoid this repetitiveness. You already saw how to do it when we were talking about custom widgets. This time we’ll do it for the original button, because all the buttons in our example should be the same. Here’s the refactored and thus simplified code: # File name: helloworld.kv # Let\u0026#39;s put all the shared stuff here. \u0026lt;Button\u0026gt;: size_hint: None, None size: 200, 50 \u0026lt;GridLayout\u0026gt;: # We need two rows. rows: 2 # And here are the buttons with just the properties that are different # for each button. Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; Here’s what you get when you run this code: So, as you can see we indeed have two rows. The GridLayout is smart enough to know how many items to put in the first row before starting the second row. I numbered the buttons on purpose. You can now easily see what order the buttons were added in: first row 1 from left to right, then row 2 from left to right, for as long as there are any widgets left.\nGridLayout cols And now I’m going to achieve the same effect using the cols property. Let’s rewrite the kv code so that we set the number of columns to 3. Here’s the kv code: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None size: 200, 50 \u0026lt;GridLayout\u0026gt;: # We need three columns now. cols: 3 Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; And here’s what we get when we run the program:\nSee any difference? Well, in this particular case there isn’t any. This is just how it works. The widgets are added from left to right, row after row. So, what if you set the number of columns to two? Let’s find out: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None size: 200, 50 \u0026lt;GridLayout\u0026gt;: # We need two columns now. cols: 2 Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; This time let’s arrange the buttons in a different way, in two columns: But still, you can see that the order of adding them is again row by row, from left to right. OK, there is much more to the GridLayout, but we’ll be talking about some other Grid-related stuff when we need it later in our project. For now, let’s move on to the next layout.\nBoxLayout The BoxLayout is a very common layout and we’ll be making use of it a lot in our project. You can imagine it as a GridLayout with just one row or one column. If you want all the elements to be positioned in one row, you should set the orientation property to ‘horizontal’, or just leave it out altogether as this is the default value. If you want the elements to be in a column, you should set orientation to ‘vertical’. Let’s see how it works. Here’s the Python file:\nimport kivy from kivy.app import App # We must import the BoxLayout class. from kivy.uix.boxlayout import BoxLayout class HelloWorldApp(App): def build(self): # We\u0026#39;re going to use the BoxLayout now. return BoxLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() Now, we want the five buttons that we have to be all in one row. Here’s the kv code: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the buttons slightly shorter so that they all # fit in one row. size: 100, 50 \u0026lt;BoxLayout\u0026gt;: # The buttons should be in a row. orientation: \u0026#39;horizontal\u0026#39; # this is the optional default value Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; Here the app window:\nAnd now let’s put the buttons in a column:\n# File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the buttons slightly shorter so that they all # fit in one row. size: 100, 50 \u0026lt;BoxLayout\u0026gt;: # The buttons should be in a column. orientation: \u0026#39;vertical\u0026#39; Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; Here’s the app when you run it: Watch more on Box Layouts StackLayout The next layout we’re going to talk about is the StackLayout. Let’s start with the Python code as usual: import kivy from kivy.app import App # We must import the StackLayout class. from kivy.uix.stacklayout import StackLayout class HelloWorldApp(App): def build(self): # We\u0026#39;re going to use the StackLayout now. return StackLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run()\nJust like the BoxLayout, the StackLayout also has the orientation property, but it works in a different way. This layout arranges the widgets in a specific order and automatically moves on to the next row or column when it run out of space in the current row or column. The orientation property takes one of the following values:\nrl-tb : right to left, top to bottom\nlr-tb : left to right, top to bottom\nrl-bt : right to left, bottom to top\nlr-bt : left to right, bottom to top\nLet’s try the out. Here’s the kv code: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the buttons slightly bigger. size: 300, 200 \u0026lt;StackLayout\u0026gt;: # The buttons should be arranged from right to left, top to bottom. orientation: \u0026#39;rl-tb\u0026#39; Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; Here’s the app window. Watch what order the buttons appear in: first right to left and then top to bottom. Now let’s test the other combinations. There are only changes in the kv file. So, how about the order from left to right, top to bottom? Here’s the code: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None size: 300, 200 \u0026lt;StackLayout\u0026gt;: # The buttons should be arranged from left to right, top to bottom. orientation: \u0026#39;lr-tb\u0026#39; Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; Watch the result now: And now right to left, bottom to top:\n# File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None size: 300, 200 \u0026lt;StackLayout\u0026gt;: # The buttons should be arranged from right to left, bottom to top. orientation: \u0026#39;rl-bt\u0026#39; Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; And the app now looks like this: Finally, left to right, bottom to top:\n# File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None size: 300, 200 \u0026lt;StackLayout\u0026gt;: # The buttons should be arranged from left to right, bottom to top. orientation: \u0026#39;lr-bt\u0026#39; Button: text: \u0026#39;Button 1\u0026#39; Button: text: \u0026#39;Button 2\u0026#39; Button: text: \u0026#39;Button 3\u0026#39; Button: text: \u0026#39;Button 4\u0026#39; Button: text: \u0026#39;Button 5\u0026#39; And here’s the app window: AnchorLayout We use this layout to anchor widgets in particular positions, like at the top or bottom, or on one of the sides. It lends itself well to create menus. The two properties used with this layout are anchor_x and anchor_y. Let’s first rewrite the Python file to make use of the AnchorLayout: import kivy from kivy.app import App # We must import the AnchorLayout class. from kivy.uix.anchorlayout import AnchorLayout class HelloWorldApp(App): def build(self): # We\u0026#39;re going to use the AnchorLayout now. return AnchorLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And now the kv file: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the button smaller again. size: 100, 50 \u0026lt;AnchorLayout\u0026gt;: # Let\u0026#39;s position the button in the upper right corner. anchor_x: \u0026#39;right\u0026#39; anchor_y: \u0026#39;top\u0026#39; Button: text: \u0026#39;Button\u0026#39; Here’s what the app looks like: Well, I added just one button here because otherwise the buttons would be on top of one another and only the last one would be visible unless we changed the sizes of some of them. This layout is more practical if you want to position a custom widget, or even more if you want to position another embedded layout. For example you can imagine making a menu consisting of 5 labels positioned in a row inside a BoxLayout and then positioning the whole menu inside the AnchorLayout. We’re going to see some embedding examples in the next part. And now some more examples with the AnchorLayout. Only the kv file is going to change. Here’s the first example. We want to position the button in the center (horizontally) and at the top: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the button smaller again. size: 100, 50 \u0026lt;AnchorLayout\u0026gt;: # Let\u0026#39;s position the button in top central position. anchor_x: \u0026#39;center\u0026#39; anchor_y: \u0026#39;top\u0026#39; Button: text: \u0026#39;Button\u0026#39; Here’s our app: And now let’s place the button in the lower left corner: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the button smaller again. size: 100, 50 \u0026lt;AnchorLayout\u0026gt;: # Let\u0026#39;s position the button in lower left corner. anchor_x: \u0026#39;left\u0026#39; anchor_y: \u0026#39;bottom\u0026#39; Button: text: \u0026#39;Button\u0026#39; The result is: OK, just one more example. Let’s say the button should be in the very middle. Here’s the code: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None # Let\u0026#39;s make the button smaller again. size: 100, 50 \u0026lt;AnchorLayout\u0026gt;: # Let\u0026#39;s position the button in lower left corner. anchor_x: \u0026#39;center\u0026#39; anchor_y: \u0026#39;center\u0026#39; Button: text: \u0026#39;Button\u0026#39; Now you will get this: So, now you more or less know how to use the layouts independently. In the next part I’ll show you how to embed layouts in other layouts. We’ll be embedding layouts a lot in the project.\n"},{"id":19,"href":"/dit11/appdev/basics/activity1/","title":"Activity 1","parent":"The Basics","content":" Setting up The Python Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import kivy from kivy.app import App from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout from kivy.uix.textinput import TextInput from kivy.uix.button import Button from kivy.uix.widget import Widget from kivy.properties import ObjectProperty class MyGrid(Widget): pass class MyApp(App): def build(self): return MyGrid() if __name__ == \u0026#34;__main__\u0026#34;: MyApp().run() Creating a .kv File Separated our logic from our styling and elements There are a few conventions we need to follow when creating a .kv file.\nNaming: The name of your .kv file must follow the rules below in order for python/kivy to be able to see and load the file.\nIt must be all lowercase It must match with the name of your main class. (The one that has the build method) If the name of your main class ends in \u0026ldquo;app\u0026rdquo; (lowercase or uppercase) you must not include \u0026ldquo;app\u0026rdquo; in your file name. File Location: The file must be in the same directory as your python script.\nFile Extension: The file must be saved as type *All Files and end with .kv\nFor example:\nMy main classes name is MyApp. Therefore I will name my file my.kv. \u0026lt;MyGrid\u0026gt;: GridLayout: cols:1 size: root.width, root.height GridLayout: cols:2 Label: text: \u0026#34;Name: \u0026#34; TextInput: multinline:False Button: text:\u0026#34;Submit\u0026#34; on_press: root.btn() Activity 1 Add a Surname Label and TextInput so when the user presses the submit button the surname is also included. Add a Label that welcomes the user when submit is pressed "},{"id":20,"href":"/dit11/appdev/basics/activity2/","title":"Activity 2","parent":"The Basics","content":" Create a simple calculator Setting up The Python Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import kivy from kivy.app import App from kivy.uix.widget import Widget from kivy.properties import ObjectProperty class MyGrid(Widget): pass class MyApp(App): def build(self): return MyGrid() if __name__ == \u0026#34;__main__\u0026#34;: MyApp().run() Creating a .kv File Separated our logic from our styling and elements There are a few conventions we need to follow when creating a .kv file.\nNaming: The name of your .kv file must follow the rules below in order for python/kivy to be able to see and load the file.\nIt must be all lowercase It must match with the name of your main class. (The one that has the build method) If the name of your main class ends in \u0026ldquo;app\u0026rdquo; (lowercase or uppercase) you must not include \u0026ldquo;app\u0026rdquo; in your file name. File Location: The file must be in the same directory as your python script.\nFile Extension: The file must be saved as type *All Files and end with .kv\nFor example:\nMy main classes name is MyApp. Therefore I will name my file my.kv. \u0026lt;MyGrid\u0026gt;: GridLayout: cols:1 size: root.width, root.height GridLayout: cols:2 Label: text: \u0026#34;Name: \u0026#34; TextInput: multinline:False Button: text:\u0026#34;Submit\u0026#34; on_press: root.btn() Are you ready? Using your skills and knowledge from Activity 1 start a new Kivy project to create your calculator. You will need to setup the GUI to look like the following. A Simple calculator in Python We will start by generating a random string of 12 characters. To do that we will use the function random.choice() that returns a random character from a sequence.\nWe will do the following: Create code for the button that will add the two numbers together and display the answer as a string. Remember to convert the two numbers to an integer first. Use a Try to make sure numbers only are entered. Use a horizontal Box Layout to add subtraction, multiplication and divisions buttons to the app. Add code for each new button "},{"id":21,"href":"/dit11/appdev/basics/activity3/","title":"Activity 3","parent":"The Basics","content":" Create a Password Generator Learning how to create a password generator can be the perfect project to learn or review basic Python and Kivy concepts.\nTo create a password generator in Python you can use a for loop that randomly selects alphanumeric characters, digits and punctuation characters to generate the password string. You can set the password length that defines the number of loop iterations. Also, using a nested for loop you can improve the password generator to generate multiple passwords.\nWe will start with a simple password generator and then we will refactor the code to make it more flexible.\nAre you ready? Using your skills and knowledge from Activity 1 start a new Kivy project to create your password generator. The following tutorial will focus in on the code that will be used for your button. You will need to setup the GUI. A Simple Password Generator in Python We will start by generating a random string of 12 characters. To do that we will use the function random.choice() that returns a random character from a sequence.\nWe will do the following: Import the random module. Set the password length to 12. Define a list of characters that we will use to generate the random password. In this first version of the program we will use just a few letters and numbers. Create an empty string called password. Write a for loop that executes 12 iterations and that at every iteration selects a random character from the string characters and appends it to the password string. Print the password we have generated. Import Random at the top of your code 1 import random The following will need to be triggered by a button. 1 2 3 4 5 6 7 8 9 10 password_length = 12 characters = \u0026#34;abcde12345\u0026#34; password = \u0026#34;\u0026#34; for index in range(password_length): password = password + random.choice(characters) print(\u0026#34;Password generated: {}\u0026#34;.format(password)) And here is an example of a password generated with this code: Password generated: dcb4a2c4aac5 As you can see the password is not strong considering that we have used a limited number of characters and numbers.\nIn the next section we will make it more secure.\nHow to Generate a Password Using All Alphanumeric Characters Let’s improve the complexity of the password by using all alphanumeric characters.\nTo do that we could simply update the value of the characters string to include all letters and numbers but it would be time consuming and prone to errors.\nWhat can we do instead?\nWe can import the Python string module that provides a few constants that we can use in the generation of a password.\nHere are few examples: \u0026gt;\u0026gt;\u0026gt; import string \u0026gt;\u0026gt;\u0026gt; string.ascii_lowercase \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; \u0026gt;\u0026gt;\u0026gt; string.ascii_uppercase \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; \u0026gt;\u0026gt;\u0026gt; string.ascii_letters \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; \u0026gt;\u0026gt;\u0026gt; string.digits \u0026#39;0123456789\u0026#39; \u0026gt;\u0026gt;\u0026gt; string.punctuation \u0026#39;!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~\u0026#39;\nWe won’t use string.ascii_lowercase or string.ascii_uppercase considering that they are both included instring.ascii_letters.\nIn our password generator we will use the following three sets of characters:\nstring.ascii_letters string.digits string.punctuation We will use the + symbol to concatenate the three sets of characters to create a single string that we will assign to the characters variable.\nThis is what you get if you concatenate the three sets of characters in the Python shell: \u0026gt;\u0026gt;\u0026gt; string.ascii_letters + string.digits + string.punctuation \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~\u0026#39; Let’s update our program… 1 2 3 4 5 6 7 8 9 10 11 12 import random, string password_length = 12 characters = string.ascii_letters + string.digits + string.punctuation password = \u0026#34;\u0026#34; for index in range(password_length): password = password + random.choice(characters) print(\u0026#34;Password generated: {}\u0026#34;.format(password)) Here are three examples of passwords generated with the updated program: Password generated: iE%g.JqurkB0 Password generated: |\u0026gt;J+qbZ\u0026lt;Vl7$ Password generated: c94,JRgshz#g\nUpdate the Password Generator to Receive the Password Length as User Input Let’s make our password generator a bit more flexible.\nWe will allow the user to provide the password length instead of hardcoding it in our program. To do that we will use the input function. 1 2 3 4 5 6 7 8 9 10 11 12 import random, string password_length = int(input(\u0026#34;Provide the password length: \u0026#34;)) characters = string.ascii_letters + string.digits + string.punctuation password = \u0026#34;\u0026#34; for index in range(password_length): password = password + random.choice(characters) print(\u0026#34;Password generated: {}\u0026#34;.format(password)) Notice that we have converted the value returned by the input function into integer considering that when using Python 3 the input function returns a string.\nThe program works fine.\nConfirm it works on your machine too before continuing with this tutorial. Provide the password length: 12 Password generated: ]\u0026#34;c_ga%M^iOd\nIf you don’t convert the output of the input function into integer you get an error when you use the variable password_length in the for loop.\nHow to Create a Python Password Generator that Generates Multiple Passwords In this section we will enhance our password generator to generate a custom number of passwords.\nThe approach will be very similar to the one we have used to get the password length from the user with the input function.\nWe will do the following:\nGet the number_of passwords using the input function. Add a for loop to generate multiple passwords based on the value of the variable number_of passwords provided by the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import random, string number_of_passwords = int(input(\u0026#34;How many passwords do you want to generate? \u0026#34;)) password_length = int(input(\u0026#34;Provide the password length: \u0026#34;)) characters = string.ascii_letters + string.digits + string.punctuation for password_index in range(number_of_passwords): password = \u0026#34;\u0026#34; for index in range(password_length): password = password + random.choice(characters) print(\u0026#34;Password {} generated: {}\u0026#34;.format(password_index, password)) Note: make sure you use the correct indentation as shown in the code above.\nLet’s test our code: How many passwords do you want to generate? 3 Provide the password length: 8 Password 0 generated: 2B.1\u0026amp;=~k Password 1 generated: Wt$@1vi\u0026#39; Password 2 generated: ,aOXN_@$ It works, nice!\nHow to Generate Strong Passwords in Python Before completing this tutorial let’s find out how we can enforce a set of rules to make sure the passwords we generate are strong enough.\nWe will make sure passwords contain at least:\nthree digits two punctuation characters To do that we will use two integers that define the number of digits and punctuation characters. Then we will use multiple nested for loops. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import random, string number_of_digits = 3 number_of_punctuation_characters = 2 characters = string.ascii_letters + string.digits + string.punctuation number_of_passwords = int(input(\u0026#34;How many passwords do you want to generate? \u0026#34;)) password_length = int(input(\u0026#34;Provide the password length: \u0026#34;)) for password_index in range(number_of_passwords): password = \u0026#34;\u0026#34; for digits_index in range(number_of_digits): password = password + random.choice(string.digits) for punctuation_index in range(number_of_punctuation_characters): password = password + random.choice(string.punctuation) for index in range(password_length - number_of_digits - number_of_punctuation_characters): password = password + random.choice(string.ascii_letters) print(\u0026#34;Password {} generated: {}\u0026#34;.format(password_index, password)) Let’s have a look at a few password generated with this program: How many passwords do you want to generate? 3 Provide the password length: 10 Password 0 generated: 738\u0026lt;\u0026gt;ZKwMA Password 1 generated: 332|(SlZDT Password 2 generated: 756%#NFWHs They look fine but to make them stronger we have to avoid having digits and punctuation characters always in the same position of the password string.\nTo shuffle characters in the password string we will use the random.shuffle() function.\nWe will create a specific function that does the shuffling. 1 2 3 4 def randomize_password(password): password_list = list(password) random.shuffle(password_list) return \u0026#34;\u0026#34;.join(password_list) This function converts the password string into a list before applying random.shuffle. Then it returns a string using the string join method.\nThen update the last print statement to call therandomize_password function. 1 print(\u0026#34;Password {} generated: {}\u0026#34;.format(password_index, randomize_password(password))) And the output is…\nHow many passwords do you want to generate? 3 Provide the password length: 10 Password 0 generated: X1+dT)4U1q Password 1 generated: 2T7g+OQ-B4 Password 2 generated: g3n0\u0026lt;3O\u0026gt;if Conclusion In this tutorial you have learned how to create a password generator in Python and how to update its logic to increase the strength of the passwords.\nWe have covered a few Python core concepts:\nimporting modules. defining functions. using the input function to read user input. nested for loops. selecting random characters from a string and shuffling a string. using the string format method. Now dress up your App GUI Watch the following video Change Background Color And Text Color of Labels to improve the look of your app. Watch the following video How To Use Images With Kivy and add an image to your app. "},{"id":22,"href":"/dit11/appdev/layouts/embedlayouts/","title":"Embedding Layouts","parent":"Kivy Layout Types","content":" FloatLayouts and RelativeLayouts inside GridLayout As mentioned in the previous part, the FloatLayout and the RelativeLayout are pretty similar. The difference is that with the FloatLayout the coordinates are not relative to the position of the layout, whereas with RelativeLayout they are. Here’s a simple demonstration. We’ll use a GridLayout and embed four other layouts in it, two FloatLayouts and two RelativeLayouts. Here’s the Python code:\n1 2 3 4 5 6 7 8 9 10 11 12 import kivy from kivy.app import App # We need a GridLayout to embed the other layouts into. from kivy.uix.gridlayout import GridLayout class HelloWorldApp(App): def build(self): return GridLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And now the kv code: # File name: helloworld.kv \u0026lt;Button\u0026gt;: size_hint: None, None size: 100, 50 \u0026lt;GridLayout\u0026gt;: # Let\u0026#39;s create a GridLayout with 2 rows rows: 2 # Let\u0026#39;s add two FloatLayouts and two RelativeLayouts to the GridLayout # with two buttons in each of them. To make things clear the buttons in # the FloatLayouts will have a text starting with \u0026#39;F\u0026#39; and the buttons in # the RelativeLayouts with \u0026#39;R\u0026#39;. # FloatLayout 1 FloatLayout: Button: text: \u0026#39;F1a\u0026#39; pos: 0, 0 Button: text: \u0026#39;F1b\u0026#39; pos: 200, 200 # RelativeLayout 1 RelativeLayout: Button: text: \u0026#39;R1a\u0026#39; pos: 0, 0 Button: text: \u0026#39;R1b\u0026#39; pos: 100, 50 # RelativeLayout 2 RelativeLayout: Button: text: \u0026#39;R2a\u0026#39; pos: 100, 50 Button: text: \u0026#39;R2b\u0026#39; pos: 100, 100 # FloatLayout 2 FloatLayout: Button: text: \u0026#39;F2a\u0026#39; pos: 200, 100 Button: text: \u0026#39;F2b\u0026#39; pos: 200, 150\nIf you run this program, it’ll be quite difficult to see what it’s all about: This is because although there are four cells in the GridLayout (2 rows and 2 columns), we don’t actually see the borders between them. Let me add some border lines and annotations to the picture so that it’s clearer for you: Have a look at the two buttons, F1a and R1a. They both have the coordinates 0, 0. The former is relative to the whole window, though, whereas the latter is relative to the layout it’s in, so RelativeLayout 1.\nEmbedding Layouts: Top Menu in AnchorLayout In our next example we’ll make a top menu using a BoxLayout for the menu items. The whole menu will be embedded in an AnchorLayout. Here’s the Python code: import kivy from kivy.app import App # We need a AnchorLayout to embed the menu into. from kivy.uix.anchorlayout import AnchorLayout class HelloWorldApp(App): def build(self): return AnchorLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run()\nAnd here’s the kv code with comment # File name: helloworld.kv \u0026lt;AnchorLayout\u0026gt;: # The menu should be in the upper left corner of the program window. anchor_x: \u0026#39;left\u0026#39; anchor_y: \u0026#39;top\u0026#39; # The menu itself is a BoxLayout with horizontal orientation. # For simplicity it will just contain labels imitating the # menu items in the top menu of the Visual Studio Code editor. BoxLayout: # We need a fixed size for the BoxLayout or otherwise it # will fill the whole AnchorLayout. As we are inside the # AnchorLayout, we must set size_hint to (None, None) first # and then use size to set the size in pixels. size_hint: None, None size: 600, 50 Label: text: \u0026#39;File\u0026#39; Label: text: \u0026#39;Edit\u0026#39; Label: text: \u0026#39;Selection\u0026#39; Label: text: \u0026#39;View\u0026#39; Label: text: \u0026#39;Go\u0026#39; Label: text: \u0026#39;Run\u0026#39; Label: text: \u0026#39;Terminal\u0026#39; Label: text: \u0026#39;Help\u0026#39; If you now run the program, you will see the app window with a top menu:\nEmbedding Layouts: Toolbar with StackLayout and AnchorLayout In our next example we’ll make a toolbar and place it on one side of the window. It will contain simple square buttons placed in a StackLayout. The toolbar itself will be placed inside an AnchorLayout, just like before. This means that we don’t actually have to change the Python file this time. And here’s the kv file: # File name: helloworld.kv # All the elements in the toolbar will be square buttons. \u0026lt;Button\u0026gt;: size_hint: None, None size: 50, 50 \u0026lt;AnchorLayout\u0026gt;: # The toolbar should be on the right side of the program window, # at the top. anchor_x: \u0026#39;right\u0026#39; anchor_y: \u0026#39;top\u0026#39; # The toolbar is a StackLayout with top to bottom and then right # to left orientation. StackLayout: orientation: \u0026#39;tb-rl\u0026#39; # We need a fixed size for the StackLayout. size_hint: None, None size: 100, 300 Button: text: \u0026#39;1\u0026#39; Button: text: \u0026#39;2\u0026#39; Button: text: \u0026#39;3\u0026#39; Button: text: \u0026#39;4\u0026#39; Button: text: \u0026#39;5\u0026#39; Button: text: \u0026#39;6\u0026#39; Button: text: \u0026#39;7\u0026#39; Button: text: \u0026#39;8\u0026#39; Button: text: \u0026#39;9\u0026#39; Here’s the final effect:\nImitating Different Cell Sizes in GridLayout And one more example. In this one we’ll embed GridLayouts in a GridLayouts to imitate different cell sizes, which you may be familiar with if you ever used the Windows 8 operational system or Windows Phone systems with tiles. Let’s modify the Python file first: import kivy from kivy.app import App # We need a GridLayout to embed the other GridLayouts into. from kivy.uix.gridlayout import GridLayout # Let\u0026#39;s create a custom GridLayout to act as the outer container. class OuterGridLayout(GridLayout): pass class HelloWorldApp(App): def build(self): return OuterGridLayout() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run()\nAnd now the kv file: # File name: helloworld.kv # We\u0026#39;ll need big buttons and small buttons to represent the tiles. \u0026lt;BigButton@Button\u0026gt;: size_hint: None, None size: 200, 200 \u0026lt;SmallButton@Button\u0026gt;: size_hint: None, None size: 100, 100 \u0026lt;OuterGridLayout\u0026gt;: rows: 3 size_hint: None, None size: 600, 600 # The big buttons will be placed directly in the outer GridLayout. # The small buttons will be placed in inner GridLayouts embedded # in the outer one. BigButton: text: \u0026#39;1\u0026#39; BigButton: text: \u0026#39;2\u0026#39; BigButton: text: \u0026#39;3\u0026#39; GridLayout: rows: 2 SmallButton: text: \u0026#39;4a\u0026#39; SmallButton: text: \u0026#39;4b\u0026#39; SmallButton: text: \u0026#39;4c\u0026#39; SmallButton: text: \u0026#39;4d\u0026#39; BigButton: text: \u0026#39;5\u0026#39; BigButton: text: \u0026#39;6\u0026#39; BigButton: text: \u0026#39;7\u0026#39; BigButton: text: \u0026#39;8\u0026#39; GridLayout: rows: 2 SmallButton: text: \u0026#39;9a\u0026#39; SmallButton: text: \u0026#39;9b\u0026#39; SmallButton: text: \u0026#39;9c\u0026#39; SmallButton: text: \u0026#39;9d\u0026#39;\nIf you now run the program, you will see the following: This was the last example for now, but, as you might guess, the possibilities are countless, it all depends on what layout you need. You can nest layouts on multiple levels, which turns out to be very flexible.\nNow, with the basics of widgets and layouts covered, we could move on to the next topic, for example graphics or events in Kivy. I’m not going to do it, though. Instead we’re going to jump right into the project and we’ll stop to discuss the stuff we need when we need it. In the next part we’ll make a short break from programming and we’ll have a look at the assets that will be used in the app. And then we’ll start building the app from scratch.\n"},{"id":23,"href":"/dit11/appdev/api/","title":"API","parent":"App Development","content":""},{"id":24,"href":"/dit11/appdev/basics/widgets/","title":"More Widgets","parent":"The Basics","content":"Taken from prosperocoder.com\nThe Check Box Kivy Widget Let’s start with the check box Kivy widget. The check box is a two-state button that can be either checked or unchecked. Later we’ll see that it can be used as a radio button as well, if it’s in a group, but for now let’s just have a look at a single check box.\nThe main property of a check box is active, which is True if it’s checked and False otherwise. The basic check box event is on_active, which is fired if the state of the checkbox changes.\nLet’s replace our button from the previous part with a check box. Here are the two files, main.py and helloworld.kv with comments. Here’s the Python file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # File name: main.py import kivy from kivy.app import App # This is what you need to import in order to use a check box. from kivy.uix.checkbox import CheckBox class HelloWorldApp(App): def build(self): # Now we want a check box to be returned. return CheckBox() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() and the kv file: 1 2 3 4 5 6 # File name: helloworld.kv # Now we\u0026#39;re using the CheckBox class \u0026lt;CheckBox\u0026gt;: # The check box should be checked, so set the active property to True. active: True If you run the main.py file, you will see a checked box in the app window. You can now uncheck it and check it again to see how it works.\nFont size on_active event Let’s make the check box do something when its state changes. For now something as simple as printing out a message in the terminal will do. Here’s the kv file: 1 2 3 4 5 6 7 8 9 10 # File name: helloworld.kv # Now we\u0026#39;re using the CheckBox class \u0026lt;CheckBox\u0026gt;: # The check box should be checked, so set the active property to True. active: True # Print a message any time the box is checked or unchecked. on_active: print(\u0026#39;State changed\u0026#39;) Now run the program and try checking and unchecking the check box several times (A). You will see the ‘State changed’ message in the terminal each time you do (B):\nFont size The Toggle Button Kivy Widget The next widget I’d like to discuss is the toggle button, which shares features with both the regular button and the check box. It looks like a button at first glance, but when you press it, it remains pressed, just like the check box remains checked when you check it. So, it’s a two-state button as well. The two states are normal and down.\nYou can set the state of the button to normal or down using the state property. You can use the on_state event if something should happen when the state changes. Besides, you can use the text property as you did with the regular button.\nAlso, just like check boxes, toggle buttons may be grouped so that only one toggle button may be in the down state (i.e. pressed) at a time in a group. But this is beyond the scope of this introductory article.\nCreating and using a toggle button is easy. Let’s remove the code responsible for the check box we just created and let’s add a toggle button. Here is the Python file with comments:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # File name: main.py import kivy from kivy.app import App # This is what you need to import in order to use a toggle button. from kivy.uix.togglebutton import ToggleButton class HelloWorldApp(App): def build(self): # Now we want a toggle button to be returned. return ToggleButton() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And here’s the kv file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # File name: helloworld.kv # Now we\u0026#39;re using the ToggleButton class \u0026lt;ToggleButton\u0026gt;: # The toggle button has the text property, just like a the regular button. text: \u0026#39;not pressed\u0026#39; # The state is by default normal, so this line of code is redundant. state: \u0026#39;normal\u0026#39; # Change the text on the toggle button if its state changes. # You can use a ternary if operator. on_state: self.text = \u0026#39;not pressed\u0026#39; if self.state == \u0026#39;normal\u0026#39; else \u0026#39;pressed\u0026#39; If you now run the program, you will see that if you press the button, both its color and its text will change:\nFont size The Text Input Kivy Widget The next widget I’d like to briefly discuss is the text input. There’s much more I could write about this widget than about all the other widgets so far. However, I’m not going to do that, at least not just yet. The text input widget is going to be used later in our project, so I will discuss all the properties and events that we need in due time. For now let me just concentrate on the very basics.\nSo, a text input is a widget in which the user can enter text. Then our program can use this text in one way or another, depending on what we need. The text input widget may allow multiline text or just a single line of text. If you need the latter, just set the multiline property to False. The text property is used for the text in the text input widget, and there may also be a hint text, which is visible when the widget contains no text. This is usually used as a prompt as to what sort of data is expected in the widget. To set the hint text you use the hint_text property.\nThere are tons of other properties, which I’m not going to discuss now. There are also tons of events, which you can use if some text is entered, when it’s validated, when the widget gets focus, and so on.\nmultiline text OK, let’s have a look at a simple example with a multiline text input first. Here’s the Python code:\n# File name: main.py import kivy from kivy.app import App # This is what you need to import in order to use a text input. from kivy.uix.textinput import TextInput class HelloWorldApp(App): def build(self): # Now we want a text input to be returned. return TextInput() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And here’s the kv file: # File name: helloworld.kv # Now we\u0026#39;re using the TextInput class \u0026lt;TextInput\u0026gt;: # Let\u0026#39;s set the text property to \u0026#39;hello\u0026#39;. text: \u0026#39;hello darkness, \\nmy old \\nfriend...\u0026#39; # The multiline property is by default set to True, so this line of code is redundant. multiline: True hint_text: \u0026#39;Type some lyrics\u0026#39; If you now run the program, the text input widget will occupy the whole available space, so the whole window. This is because it’s the only widget now. As you can see, it works exactly the same as with the other widgets in this respect.\nIn the kv file we set the value of the text property to a multiline string. As you can see, you can use the newline escape sequence inside your string. This is what you get:\nFont size hint text Now click anywhere inside the widget and you can edit the text. In order to move to a new line you just need to hit Enter. And now delete all the text and you will see the hint text that we set in the kv file: Font size single line text And now suppose we want to only allow single line text. All you have to do is set the multiline property to False:\n# File name: helloworld.kv # Now we\u0026#39;re using the TextInput class \u0026lt;TextInput\u0026gt;: # Remove the newline characters because this is going # to be single line text. text: \u0026#39;hello darkness, my old friend...\u0026#39; multiline: False hint_text: \u0026#39;Type some lyrics\u0026#39; I also changed the text property because now we can only have a single line of text. Run the program again and if you now try to edit the text, you will notice that the Enter key will no longer let you go to a new line. Actually, what it now does is make the text input widget lose focus and validate the text entered in it, but in our case there isn’t any validation code, so there’s nothing to validate. Font size There’s much more to text inputs than that, but let me now move on to the last widget I’d like to introduce in this article, the slider.\nThe Slider Kivy Widget The slider looks like a scrollbar. You can use it to set a value between a minimum and a maximum value. The main properties of a slider are min, max and value, which you can use to set the just mentioned values. The min and max properties are self-explanatory. The value property is the default value.\nBesides, sliders may be oriented horizontally (by default) or vertically, depending on what you set the orientation property to.\nSo, this is enough for us to know to create a simple slider. Let it be a horizontal slider with values between -100 and 200 and with the default value of 0. Here’s the Python file: # File name: main.py import kivy from kivy.app import App # This is what you need to import in order to use a slider. from kivy.uix.slider import Slider class HelloWorldApp(App): def build(self): # Now we want a slider to be returned. return Slider() if __name__ == \u0026#39;__main__\u0026#39;: HelloWorldApp().run() And here’s the kv file: 1 2 3 4 5 6 7 8 9 10 11 12 13 File name: helloworld.kv # Now we\u0026#39;re using the Slider class \u0026lt;Slider\u0026gt;: # The min and max values should be -100 and 200 respectively. min: -100 max: 200 # The default value should be 0. value: 0 # The default orientation is horizontal, so you don\u0026#39;t need this # line of code now, but, of course, it will do no harm if it\u0026#39;s there. orientation: \u0026#39;horizontal\u0026#39; Now run the program. You will see the slider occupy the whole window. It’s set to the default value of 0, but you can slide it to the left and to the right. Give it a try. Font size vertical orientation And now change the orientation to vertical and run the program again. Here’s the kv file: 1 2 3 4 5 6 7 8 9 10 11 # File name: helloworld.kv # Now we\u0026#39;re using the Slider class \u0026lt;Slider\u0026gt;: # The min and max values should be -100 and 200 respectively. min: -100 max: 200 # The default value should be 0. value: 0 orientation: \u0026#39;vertical\u0026#39; "},{"id":25,"href":"/dit11/appdev/gettingStarted/flowcharts/","title":"Flowcharts","parent":"Getting Started","content":"Flowcharts are a visual representation of program flow. A flowchart normally uses a combination of blocks and arrows to represent actions and sequence. Blocks typically represent actions. The order in which actions occur is shown using arrows that point from statement to statement. Sometimes a block will have multiple arrows coming out of it, representing a step where a decision must be made about which path to follow.\nStart and End symbols are represented as rounded rectangles, usually containing the word \u0026ldquo;Star\u0026rdquo; or \u0026ldquo;End\u0026rdquo;, but can be more specific such as \u0026ldquo;Power Robot Off\u0026rdquo; or \u0026ldquo;Stop All Motors\u0026rdquo;.\nActions are represented as rectangles and act as basic commands. Examples: wait(10) increment LineCount by 1 motors full ahead\nDecision blocks are represented as diamonds. These typically contain Yes/No questions. Decision blocks have two or more arrows coming Out Of them, representing the different paths that can be followed, depending on the outcome Of the decision. The arrows should always be labelled accordingly.\nExample Flowchart The following flowchart instructs a robot to run forward as long as its touch sensor is not pressed. When the touch sensor is pressed the motors stop and the program ends. Example Flowchart The following flowchart instructs a robot to run forward as long as its color sensor reflected light is less than 10%. When the color sensor reflected light is greater than 10% the robot will stop. "},{"id":26,"href":"/dit11/appdev/gettingStarted/constructs/","title":"Programming Constructs","parent":"Getting Started","content":"Programs are designed using common building blocks. These building blocks, known as programming constructs (or programming concepts), form the basis for all programs.\nThere are three basic building blocks to consider:\nsequence is the order in which instructions occur and are processed selection determines which path a program takes when it is running iteration is the repeated execution of a section of code when a program is running Sequence Sequence is the order in which programming statements are executed. Programming statements usually run one after another in order, unless one of the other programming constructs is used. The sequence of a program is extremely important as once these are translated, carrying out instructions in the wrong order leads to a program performing incorrectly.\nThe following example code will execute each line in order/sequence 1 2 3 4 print(\u0026#34;Let\u0026#39;s introduce ourselves.\u0026#34;) print(\u0026#34;My name is Eliza. What is your name?\u0026#34;) name = input() print(\u0026#34;Hello \u0026#34; + name + \u0026#34;, nice to meet you.\u0026#34;) Selection IF statements Selection is a programming construct where a section of code is run only if a condition is met. In programming, there are often occasions when a decision needs to be made. Selection is the process of making a decision. The result of the decision can either be TRUE or FALSE, this determines which path the program will take next.\nThe following code uses selection to test the condition varHeight \u0026gt; 1.6, if this condition is TRUE then \u0026ldquo;Tall enough to enter ride\u0026rdquo; is printed. 1 2 if varHeight \u0026gt; 1.6: print(\u0026#34;Tall enough to enter ride\u0026#34;) The following code uses selection to test the condition username == \u0026ldquo;Callum\u0026rdquo;, if this condition is TRUE then \u0026ldquo;Access granted\u0026rdquo; is printed. If the condition is FASLE we can use else: to execute a different line of code. 1 2 3 4 if username == \u0026#34;Callum\u0026#34;: print(\u0026#34;Access granted\u0026#34;) else: print(\u0026#34;Unknown username\u0026#34;) Iteration or Loop Programs often need to repeat certain steps while or until a condition has been met. This process is known as iteration.\nIteration or repetition is often referred to as looping, since the program ‘loops’ back to an earlier line of code.\nIteration allows programmers to simplify a program and make it more efficient. Instead of writing out the same lines of code again and again(mistages happen), a programmer can write a section of code once, and ask the program to execute the same line repeatedly until no longer needed.\nPython programming offers two kinds of loop, the for loop and the while loop. Using these loops along with loop control statements like break and continue, we can create various forms of loop.\nThe infinite loop We can create an infinite loop using while statement. If the condition of while loop is always True, we get an infinite loop.\nExample #1: Infinite loop using while 1 2 3 4 5 6 # An example of infinite loop # press Ctrl + c to exit from the loop while True: num = int(input(\u0026#34;Enter an integer: \u0026#34;)) print(\u0026#34;The double of\u0026#34;,num,\u0026#34;is\u0026#34;,2 * num) Output Enter an integer: 3 The double of 3 is 6 Enter an integer: 5 The double of 5 is 10 Enter an integer: 6 The double of 6 is 12 Enter an integer: Traceback (most recent call last):\nLoop with condition at the top This is a normal while loop without break statements. The condition of the while loop is at the top and the loop terminates when this condition is False.\nFlowchart of Loop With Condition at Top Example #2: Loop with condition at the top 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Program to illustrate a loop with the condition at the top # Try different numbers n = 10 # Uncomment to get user input #n = int(input(\u0026#34;Enter n: \u0026#34;)) # initialize sum and counter sum = 0 i = 1 while i \u0026lt;= n: sum = sum + i i = i+1 # update counter # print the sum print(\u0026#34;The sum is\u0026#34;,sum) Loop with condition in the middle This kind of loop can be implemented using an infinite loop along with a conditional break in between the body of the loop.\nFlowchart of Loop with Condition in Middle Example #3: Loop with condition in the middle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Program to illustrate a loop with condition in the middle. # Take input from the user until a vowel is entered vowels = \u0026#34;aeiouAEIOU\u0026#34; # infinite loop while True: v = input(\u0026#34;Enter a vowel: \u0026#34;) # condition in the middle if v in vowels: break print(\u0026#34;That is not a vowel. Try again!\u0026#34;) print(\u0026#34;Thank you!\u0026#34;) Output Enter a vowel: r That is not a vowel. Try again! Enter a vowel: 6 That is not a vowel. Try again! Enter a vowel: , That is not a vowel. Try again! Enter a vowel: u Thank you!\nLoop with condition at the bottom This kind of loop ensures that the body of the loop is executed at least once. It can be implemented using an infinite loop along with a conditional break at the end. This is similar to the do\u0026hellip;while loop in C.\nFlowchart of Loop with Condition at Bottom Example #4: Loop with condition at the bottom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Python program to illustrate a loop with the condition at the bottom # Roll a dice until the user chooses to exit # import random module import random while True: input(\u0026#34;Press enter to roll the dice\u0026#34;) # get a number between 1 to 6 num = random.randint(1,6) print(\u0026#34;You got\u0026#34;,num) option = input(\u0026#34;Roll again?(y/n) \u0026#34;) # condition if option == \u0026#39;n\u0026#39;: break Output Press enter to roll the dice You got 1 Roll again?(y/n) y Press enter to roll the dice You got 5 Roll again?(y/n) What is FOR loop in Python? The for loop in Python is used to iterate over a sequence (list, tuple, string) or other iterable objects. Iterating over a sequence is called traversal.\nSyntax of for Loop for val in sequence: loop body Here, val is the variable that takes the value of the item inside the sequence on each iteration.\nLoop continues until we reach the last item in the sequence. The body of for loop is separated from the rest of the code using indentation.\nFlowchart of for Loop Example: Python for Loop 1 2 3 4 5 6 7 8 9 10 11 12 13 # Program to find the sum of all numbers stored in a list # List of numbers numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11] # variable to store the sum sum = 0 # iterate over the list for val in numbers: sum = sum+val print(\u0026#34;The sum is\u0026#34;, sum) When you run the program, the output will be: The sum is 48\n"},{"id":27,"href":"/dit11/glossary/","title":"Glossary","parent":"11 DigiTech","content":""},{"id":28,"href":"/dit11/troubleshooting/","title":"Troubleshooting","parent":"11 DigiTech","content":""},{"id":29,"href":"/dit11/reference/","title":"Reference materials","parent":"11 DigiTech","content":" Robotics LEGO MicroPython Documentation LEGO Python for EV3 EV3 Tutorial Game Design Pygame Zero documentation Physics for Game Developers Teaching a kid to code with Pygame Zero "},{"id":30,"href":"/dit11/teaching/","title":"Teaching materials","parent":"11 DigiTech","content":""},{"id":31,"href":"/dit11/","title":"11 DigiTech","parent":"","content":"Welcome to Year 11 Digital Technologies!\nThis semester we will work on two broad topics:\nApp development in Kivy using Python game design using Unity Kivy "},{"id":32,"href":"/dit11/glossary/argument/","title":"argument","parent":"Glossary","content":"When calling a function, the values given to it are called arguments. For example, in this case:\ntotal = add(3, 4) 3 and 4 are arguments to the function add().\nWhen defining a function, the pieces of information that the function takes to do its job are called parameters.\n"},{"id":33,"href":"/dit11/categories/","title":"Categories","parent":"11 DigiTech","content":""},{"id":34,"href":"/dit11/glossary/coordinate/","title":"co-ordinate system","parent":"Glossary","content":"In most programming environments (such as Pygame Zero), the screen co-ordinate system uses (x, y) co-ordinates, with the origin (0, 0) in the top left corner of the screen, with x to the right, and y going down.\nEverything to be displayed on the screen must be rastered, which means rendered into a grid of colored pixels.\n"},{"id":35,"href":"/dit11/glossary/color/","title":"color/colour","parent":"Glossary","content":"In almost all programming, American spellings are used. So as programmers we use colors, even though we would normally spell the word colours.\nFor most programming, colors are described by the amount of red, green, and blue light to emit. These numbers are normally in the range 0-255. In Pygame Zero, we list these as a tuple (red, green, blue), such as:\n(0, 150, 255) You can use the Google Color Picker to find different colors, and then copy the RGB value listed.\n"},{"id":36,"href":"/dit11/glossary/parameter/","title":"parameter","parent":"Glossary","content":"When defining a function, the pieces of information that the function takes to do its job are called parameters. For example, here:\ndef add(first, second): return first + second first and second are the parameters of the function add().\nWhen calling a function, the values given to it are called arguments.\n"},{"id":37,"href":"/dit11/teaching/siteUrl/","title":"Site URL 🡄🡆","parent":"Teaching materials","content":"Learn about Pygame Zero here:\nhttps://tmcdigitech.github.io/dit8/\n"},{"id":38,"href":"/dit11/tags/","title":"Tags","parent":"11 DigiTech","content":""},{"id":39,"href":"/dit11/glossary/tuple/","title":"tuple","parent":"Glossary","content":"A tuple is a single unit of data made up of multiple values. In Python they are defined using round brackets, with commas separating the values. Tuples can contain all sorts of data as values, but in Pygame Zero we use them most often for colors (red, green, blue) and co-ordinates (x, y).\n"},{"id":40,"href":"/dit11/troubleshooting/01whybroken/","title":"Why won't my program work?","parent":"Troubleshooting","content":"Here is a checklist of things to look for if something is wrong\u0026hellip;\nSpelling and Capitalisation Remember that the computer is really, really, really, really stupid. It will recognise only words it has been taught; it is not clever enough to handle spelling mistakes - these will confuse it. It is also not clever enough to know that most of the time we use A and a interchangeably, so you have to make sure that if the computer is expecting a capital letter, you give it one, and vice versa.\n"}]